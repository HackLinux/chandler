--- db-4.4.20/dbinc/db.in	2005-11-10 17:18:00.000000000 -0800
+++ db-4.4.20-patched/dbinc/db.in	2005-12-26 09:28:41.000000000 -0800
@@ -181,6 +181,7 @@
 #define	DB_DBT_REALLOC		0x010	/* Return in realloc'd memory. */
 #define	DB_DBT_USERMEM		0x020	/* Return in user's memory. */
 #define	DB_DBT_DUPOK		0x040	/* Insert if duplicate. */
+#define	DB_DBT_USERCOPY		0x080	/* User copy fn. */
 	u_int32_t flags;
 };
 
--- db-4.4.20/db/db_iface.c	2005-11-09 07:21:22.000000000 -0800
+++ db-4.4.20-patched/db/db_iface.c	2005-12-26 13:24:50.000000000 -0800
@@ -2339,20 +2339,21 @@
 	 */
 	if ((ret = __db_fchk(dbenv, name, dbt->flags, DB_DBT_APPMALLOC |
 	    DB_DBT_MALLOC | DB_DBT_DUPOK | DB_DBT_REALLOC | DB_DBT_USERMEM |
-	    DB_DBT_PARTIAL)) != 0)
+	    DB_DBT_PARTIAL | DB_DBT_USERCOPY)) != 0)
 		return (ret);
-	switch (F_ISSET(dbt, DB_DBT_MALLOC | DB_DBT_REALLOC | DB_DBT_USERMEM)) {
+	switch (F_ISSET(dbt, DB_DBT_MALLOC | DB_DBT_REALLOC | DB_DBT_USERMEM | DB_DBT_USERCOPY)) {
 	case 0:
 	case DB_DBT_MALLOC:
 	case DB_DBT_REALLOC:
 	case DB_DBT_USERMEM:
+	case DB_DBT_USERCOPY:
 		break;
 	default:
 		return (__db_ferr(dbenv, name, 1));
 	}
 
 	if (check_thread && DB_IS_THREADED(dbp) &&
-	    !F_ISSET(dbt, DB_DBT_MALLOC | DB_DBT_REALLOC | DB_DBT_USERMEM)) {
+	    !F_ISSET(dbt, DB_DBT_MALLOC | DB_DBT_REALLOC | DB_DBT_USERMEM | DB_DBT_USERCOPY)) {
 		__db_err(dbenv,
 		    "DB_THREAD mandates memory allocation flag on DBT %s",
 		    name);
--- db-4.4.20/db/db_overflow.c	2005-08-08 10:30:51.000000000 -0700
+++ db-4.4.20-patched/db/db_overflow.c	2006-01-03 11:01:42.000000000 -0800
@@ -85,8 +85,9 @@
 	DB_MPOOLFILE *mpf;
 	PAGE *h;
 	db_indx_t bytes;
-	u_int32_t curoff, needed, start;
+	u_int32_t curoff, needed, start, offset;
 	u_int8_t *p, *src;
+    int (*copyfn)(DBT *, void *, u_int32_t, u_int32_t);
 	int ret;
 
 	dbenv = dbp->dbenv;
@@ -117,6 +118,10 @@
 			dbt->size = needed;
 			return (DB_BUFFER_SMALL);
 		}
+	} else if (F_ISSET(dbt, DB_DBT_USERCOPY)) {
+        if (dbt->data == NULL)
+            return EINVAL;
+        copyfn = (int (*)(DBT *, void *, u_int32_t, u_int32_t)) dbt->data;
 	} else if (F_ISSET(dbt, DB_DBT_MALLOC)) {
 		if ((ret = __os_umalloc(dbenv, needed, &dbt->data)) != 0)
 			return (ret);
@@ -143,28 +148,56 @@
 	 * one into the buffer.  Never copy more than the total data length.
 	 */
 	dbt->size = needed;
-	for (curoff = 0, p = dbt->data; pgno != PGNO_INVALID && needed > 0;) {
-		if ((ret = __memp_fget(mpf, &pgno, 0, &h)) != 0)
-			return (ret);
 
-		/* Check if we need any bytes from this page. */
-		if (curoff + OV_LEN(h) >= start) {
-			src = (u_int8_t *)h + P_OVERHEAD(dbp);
-			bytes = OV_LEN(h);
-			if (start > curoff) {
-				src += start - curoff;
-				bytes -= start - curoff;
-			}
-			if (bytes > needed)
-				bytes = needed;
-			memcpy(p, src, bytes);
-			p += bytes;
-			needed -= bytes;
-		}
-		curoff += OV_LEN(h);
-		pgno = h->next_pgno;
-		(void)__memp_fput(mpf, h, 0);
-	}
+    if (F_ISSET(dbt, DB_DBT_USERCOPY))
+        for (curoff = 0, offset = 0; pgno != PGNO_INVALID && needed > 0;) {
+            if ((ret = __memp_fget(mpf, &pgno, 0, &h)) != 0)
+                return (ret);
+
+            /* Check if we need any bytes from this page. */
+            if (curoff + OV_LEN(h) >= start) {
+                src = (u_int8_t *)h + P_OVERHEAD(dbp);
+                bytes = OV_LEN(h);
+                if (start > curoff) {
+                    src += start - curoff;
+                    bytes -= start - curoff;
+                }
+                if (bytes > needed)
+                    bytes = needed;
+                ret = copyfn(dbt, src, bytes, offset);
+                if (ret)
+                    return ret;
+                offset += bytes;
+                needed -= bytes;
+            }
+            curoff += OV_LEN(h);
+            pgno = h->next_pgno;
+            (void)__memp_fput(mpf, h, 0);
+        }
+    else
+        for (curoff = 0, p = dbt->data; pgno != PGNO_INVALID && needed > 0;) {
+            if ((ret = __memp_fget(mpf, &pgno, 0, &h)) != 0)
+                return (ret);
+
+            /* Check if we need any bytes from this page. */
+            if (curoff + OV_LEN(h) >= start) {
+                src = (u_int8_t *)h + P_OVERHEAD(dbp);
+                bytes = OV_LEN(h);
+                if (start > curoff) {
+                    src += start - curoff;
+                    bytes -= start - curoff;
+                }
+                if (bytes > needed)
+                    bytes = needed;
+                memcpy(p, src, bytes);
+                p += bytes;
+                needed -= bytes;
+            }
+            curoff += OV_LEN(h);
+            pgno = h->next_pgno;
+            (void)__memp_fput(mpf, h, 0);
+        }
+
 	return (0);
 }
 
--- db-4.4.20/db/db_ret.c	2005-06-16 13:21:14.000000000 -0700
+++ db-4.4.20-patched/db/db_ret.c	2006-01-03 11:12:03.000000000 -0800
@@ -126,6 +126,14 @@
 	} else if (F_ISSET(dbt, DB_DBT_USERMEM)) {
 		if (len != 0 && (dbt->data == NULL || dbt->ulen < len))
 			ret = DB_BUFFER_SMALL;
+	} else if (F_ISSET(dbt, DB_DBT_USERCOPY)) {
+        if (dbt->data == NULL)
+            ret = EINVAL;
+        else
+        {
+            dbt->size = len;
+            return ((int (*)(DBT *, void *, u_int32_t, u_int32_t)) dbt->data)(dbt, data, len, 0);
+        }
 	} else if (memp == NULL || memsize == NULL) {
 		ret = EINVAL;
 	} else {
--- db-4.4.20/build_win32/db.h	2005-11-12 09:42:57.000000000 -0800
+++ db-4.4.20-patched/build_win32/db.h	2006-01-03 14:32:25.000000000 -0800
@@ -188,6 +188,7 @@
 #define	DB_DBT_REALLOC		0x010	/* Return in realloc'd memory. */
 #define	DB_DBT_USERMEM		0x020	/* Return in user's memory. */
 #define	DB_DBT_DUPOK		0x040	/* Insert if duplicate. */
+#define	DB_DBT_USERCOPY		0x080	/* User copy fn. */
 	u_int32_t flags;
 };
 
