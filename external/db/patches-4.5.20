--- db-4.5.20/dbinc/db.in	2006-09-13 09:22:37.000000000 -0700
+++ db-4.5.20-patched/dbinc/db.in	2006-11-29 15:41:26.000000000 -0800
@@ -187,16 +187,19 @@
 #define	DB_DBT_ISSET		0x002	/* Lower level calls set value. */
 #define	DB_DBT_MALLOC		0x004	/* Return in malloc'd memory. */
 #define	DB_DBT_PARTIAL		0x008	/* Partial put/get. */
 #define	DB_DBT_REALLOC		0x010	/* Return in realloc'd memory. */
 #define	DB_DBT_USERCOPY		0x020	/* Use the user-supplied callback. */
 #define	DB_DBT_USERMEM		0x040	/* Return in user's memory. */
 #define	DB_DBT_DUPOK		0x080	/* Insert if duplicate. */
 	u_int32_t flags;
+
+	int (*usercopy)
+	    __P((DBT *, u_int32_t, void *, u_int32_t, u_int32_t));
 };
 
 /*
  * Common flags --
  *	Interfaces which use any of these common flags should never have
  *	interface specific flags in this range.
  */
 #define	DB_CREATE	      0x0000001	/* Create file as necessary. */
@@ -1983,18 +1986,16 @@
 					/* App-specified alloc functions. */
 	void *(*db_malloc) __P((size_t));
 	void *(*db_realloc) __P((void *, size_t));
 	void (*db_free) __P((void *));
 
 	/* Application callback to copy data to/from a custom data source. */
 #define	DB_USERCOPY_GETDATA	0x0001
 #define	DB_USERCOPY_SETDATA	0x0002
-	int (*dbt_usercopy)
-	    __P((DBT *, u_int32_t, void *, u_int32_t, u_int32_t));
 
 	/*
 	 * Currently, the verbose list is a bit field with room for 32
 	 * entries.  There's no reason that it needs to be limited, if
 	 * there are ever more than 32 entries, convert to a bit array.
 	 */
 #define	DB_VERB_DEADLOCK	0x0001	/* Deadlock detection information. */
 #define	DB_VERB_RECOVERY	0x0002	/* Recovery information. */
--- db-4.5.20/build_windows/db.h	2006-09-20 13:07:23.000000000 -0700
+++ db-4.5.20-patched/build_windows/db.h	2006-11-29 16:06:32.000000000 -0800
@@ -212,16 +212,19 @@
 #define	DB_DBT_ISSET		0x002	/* Lower level calls set value. */
 #define	DB_DBT_MALLOC		0x004	/* Return in malloc'd memory. */
 #define	DB_DBT_PARTIAL		0x008	/* Partial put/get. */
 #define	DB_DBT_REALLOC		0x010	/* Return in realloc'd memory. */
 #define	DB_DBT_USERCOPY		0x020	/* Use the user-supplied callback. */
 #define	DB_DBT_USERMEM		0x040	/* Return in user's memory. */
 #define	DB_DBT_DUPOK		0x080	/* Insert if duplicate. */
 	u_int32_t flags;
+
+	int (*usercopy)
+	    __P((DBT *, u_int32_t, void *, u_int32_t, u_int32_t));
 };
 
 /*
  * Common flags --
  *	Interfaces which use any of these common flags should never have
  *	interface specific flags in this range.
  */
 #define	DB_CREATE	      0x0000001	/* Create file as necessary. */
@@ -2008,18 +2011,16 @@
 					/* App-specified alloc functions. */
 	void *(*db_malloc) __P((size_t));
 	void *(*db_realloc) __P((void *, size_t));
 	void (*db_free) __P((void *));
 
 	/* Application callback to copy data to/from a custom data source. */
 #define	DB_USERCOPY_GETDATA	0x0001
 #define	DB_USERCOPY_SETDATA	0x0002
-	int (*dbt_usercopy)
-	    __P((DBT *, u_int32_t, void *, u_int32_t, u_int32_t));
 
 	/*
 	 * Currently, the verbose list is a bit field with room for 32
 	 * entries.  There's no reason that it needs to be limited, if
 	 * there are ever more than 32 entries, convert to a bit array.
 	 */
 #define	DB_VERB_DEADLOCK	0x0001	/* Deadlock detection information. */
 #define	DB_VERB_RECOVERY	0x0002	/* Recovery information. */
--- db-4.5.20/db/db_iface.c	2006-09-19 17:20:57.000000000 -0700
+++ db-4.5.20-patched/db/db_iface.c	2006-11-29 15:42:52.000000000 -0800
@@ -2531,17 +2531,17 @@
 	int ret;
 
 	if (dbt == NULL || !F_ISSET(dbt, DB_DBT_USERCOPY) || dbt->size == 0 ||
 	    dbt->data != NULL)
 		return (0);
 
 	buf = NULL;
 	if ((ret = __os_umalloc(dbenv, dbt->size, &buf)) != 0 ||
-	    (ret = dbenv->dbt_usercopy(dbt, 0, buf, dbt->size,
+	    (ret = dbt->usercopy(dbt, 0, buf, dbt->size,
 	    DB_USERCOPY_GETDATA)) != 0)
 		goto err;
 	dbt->data = buf;
 
 	return (0);
 
 err:	if (buf != NULL) {
 		__os_ufree(dbenv, buf);
--- db-4.5.20/db/db_overflow.c	2006-08-24 07:56:12.000000000 -0700
+++ db-4.5.20-patched/db/db_overflow.c	2006-11-29 15:47:43.000000000 -0800
@@ -152,17 +152,17 @@
 			src = (u_int8_t *)h + P_OVERHEAD(dbp);
 			if (start > curoff) {
 				src += start - curoff;
 				bytes -= start - curoff;
 			}
 			if (bytes > needed)
 				bytes = needed;
 			if (F_ISSET(dbt, DB_DBT_USERCOPY)) {
-				if ((ret = dbenv->dbt_usercopy(dbt, curoff,
+				if ((ret = dbt->usercopy(dbt, curoff,
 				    src, bytes, DB_USERCOPY_SETDATA)) != 0) {
 					(void)__memp_fput(mpf, h, 0);
 					return (ret);
 				}
 			} else
 				memcpy(p, src, bytes);
 			p += bytes;
 			needed -= bytes;
--- db-4.5.20/db/db_ret.c	2006-08-24 07:56:12.000000000 -0700
+++ db-4.5.20-patched/db/db_ret.c	2006-11-29 15:49:35.000000000 -0800
@@ -110,17 +110,17 @@
 	 * Use the memory specified by the application: DB_DBT_USERMEM.
 	 *
 	 * !!!
 	 * If the length we're going to copy is 0, the application-supplied
 	 * memory pointer is allowed to be NULL.
 	 */
 	if (F_ISSET(dbt, DB_DBT_USERCOPY)) {
 		dbt->size = len;
-		return (len == 0 ? 0 : dbenv->dbt_usercopy(dbt, 0, data,
+		return (len == 0 ? 0 : dbt->usercopy(dbt, 0, data,
 		    len, DB_USERCOPY_SETDATA));
 
 	} else if (F_ISSET(dbt, DB_DBT_MALLOC))
 		ret = __os_umalloc(dbenv, len, &dbt->data);
 	else if (F_ISSET(dbt, DB_DBT_REALLOC)) {
 		if (dbt->data == NULL || dbt->size == 0 || dbt->size < len)
 			ret = __os_urealloc(dbenv, len, &dbt->data);
 	} else if (F_ISSET(dbt, DB_DBT_USERMEM)) {
--- db-4.5.20/libdb_java/db_java_wrap.c	2006-09-20 13:07:32.000000000 -0700
+++ db-4.5.20-patched/libdb_java/db_java_wrap.c	2006-11-29 16:11:38.000000000 -0800
@@ -1351,18 +1351,20 @@
 				ldbt->jdata_nio);
 		dbt->data = (u_int8_t *)dbt->data + ldbt->offset;
 	} else if (F_ISSET(dbt, DB_DBT_USERMEM)) {
 		if (ldbt->jarr != NULL &&
 		    (dbt->data = (*jenv)->GetByteArrayElements(jenv,
 		    ldbt->jarr, NULL)) == NULL)
 			return (EINVAL); /* an exception will be pending */
 		dbt->data = (u_int8_t *)dbt->data + ldbt->offset;
-	} else
+	} else {
 		F_SET(dbt, DB_DBT_USERCOPY);
+		dbt->usercopy = __dbj_dbt_memcopy;
+    }
 	dbt->app_data = ldbt;
 
 	return (0);
 }
 
 static void __dbj_dbt_release(
     JNIEnv *jenv, jobject jdbt, DBT *dbt, DBT_LOCKED *ldbt) {
 	jthrowable t;
@@ -2198,18 +2200,16 @@
 #define	DbTxn __db_txn
 
 /* Suppress a compilation warning for an unused symbol */
 void *unused = SWIG_JavaThrowException;
 
 SWIGINTERN struct Db *new_Db(DB_ENV *dbenv,u_int32_t flags){
 		DB *self = NULL;
 		errno = db_create(&self, dbenv, flags);
-		if (errno == 0 && dbenv == NULL)
-			self->dbenv->dbt_usercopy = __dbj_dbt_memcopy;
 		return self;
 	}
 SWIGINTERN db_ret_t Db_associate(struct Db *self,DB_TXN *txnid,DB *secondary,int (*callback)(DB *,DBT const *,DBT const *,DBT *),u_int32_t flags){
 		return self->associate(self, txnid, secondary, callback, flags);
 	}
 SWIGINTERN db_ret_t Db_compact(struct Db *self,DB_TXN *txnid,DBT *start,DBT *stop,DB_COMPACT *c_data,u_int32_t flags,DBT *end){
 		return self->compact(self, txnid, start, stop, c_data, flags,
 		    end);
@@ -2474,18 +2474,16 @@
 		return self->c_pget(self, key, pkey, data, flags);
 	}
 SWIGINTERN int Dbc_put(struct Dbc *self,DBT *key,DBT *data,u_int32_t flags){
 		return self->c_put(self, key, data, flags);
 	}
 SWIGINTERN struct DbEnv *new_DbEnv(u_int32_t flags){
 		DB_ENV *self = NULL;
 		errno = db_env_create(&self, flags);
-		if (errno == 0)
-			self->dbt_usercopy = __dbj_dbt_memcopy;
 		return self;
 	}
 SWIGINTERN db_ret_t DbEnv_close(struct DbEnv *self,u_int32_t flags){
 		return self->close(self, flags);
 	}
 SWIGINTERN db_ret_t DbEnv_dbremove(struct DbEnv *self,DB_TXN *txnid,char const *file,char const *database,u_int32_t flags){
 		return self->dbremove(self, txnid, file, database, flags);
 	}
--- db-4.5.20/os/os_fsync.c	2006-12-06 12:29:17.000000000 -0800
+++ db-4.5.20-patched/os/os_fsync.c	2006-12-06 12:25:25.000000000 -0800
@@ -68,23 +68,28 @@
 	 * Do nothing if the file descriptor has been marked as not requiring
 	 * any sync to disk.
 	 */
 	if (F_ISSET(fhp, DB_FH_NOSYNC))
 		return (0);
 
 	if (DB_GLOBAL(j_fsync) != NULL)
 		ret = DB_GLOBAL(j_fsync)(fhp->fd);
-	else
+	else {
 #if defined(F_FULLFSYNC)
 		RETRY_CHK((fcntl(fhp->fd, F_FULLFSYNC, 0)), ret);
+                if (ret == ENOTSUP) {
+                    ret = 0;
+                    RETRY_CHK((fsync(fhp->fd)), ret);
+                }
 #elif defined(HAVE_FDATASYNC)
 		RETRY_CHK((fdatasync(fhp->fd)), ret);
 #else
 		RETRY_CHK((fsync(fhp->fd)), ret);
 #endif
+        }
 
 	if (ret != 0) {
 		__db_syserr(dbenv, ret, "fsync");
 		ret = __os_posix_err(ret);
 	}
 	return (ret);
 }
