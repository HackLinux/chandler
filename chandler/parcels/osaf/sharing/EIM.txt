----------------------
The Sharing Record API
----------------------


>>> import osaf.sharing.eim as sharing   # API kludge during initial dev & testing
>>> from decimal import Decimal


Record Types and Fields
=======================

Record types are defined by subclassing ``sharing.Record`` and creating
``sharing.key`` and ``sharing.field`` attributes to describe their layout::

    >>> class Demo(sharing.Record):
    ...     URI = 'cid:eim.test.demo-record@osaf.us'
    ...     itemNumber  = sharing.key(int)
    ...     itemName    = sharing.field(sharing.TextType(size=50))
    ...     description = sharing.field(sharing.TextType(size=500))
    ...     price       = sharing.field(sharing.DecimalType(None, 6, 2))

    >>> r1 = Demo(1,"Foo", "This is a foo", Decimal('2.50'))

    >>> r1
    Demo(1, u'Foo', u'This is a foo', Decimal("2.50"))

Each record type can have an (optional) unique URI, that can be looked up using
the ``sharing.lookupSchemaURI()`` API:

    >>> sharing.lookupSchemaURI('cid:eim.test.demo-record@osaf.us')
    <class 'Demo'>

But each record type must have a *unique* URI; duplicating the URI is an
error::

    >>> class Wrong(sharing.Record):
    ...     URI = 'cid:eim.test.demo-record@osaf.us'    # same as before
    Traceback (most recent call last):
      ...
    TypeError: URI 'cid:eim.test.demo-record@osaf.us' is already in use


Creating diffs from records::

    >>> r1 - r1     # no change between these records
    NoChange

    >>> r1 - 123
    Traceback (most recent call last):
      ...
    TypeError: 123 is not a Demo record

    >>> r1 - Demo(2, "baz", "spam", Decimal('1.29'))
    Traceback (most recent call last):
      ...
    ValueError: Can't subtract itemNumber 2 from itemNumber 1

    >>> r1 - Demo(1, "Bar", "This is a foo", Decimal('1.29'))
    Demo(1, u'Foo', NoChange, Decimal("2.50"))

    >>> r1 - Demo(1, "Foo", "This is NOT a foo", Decimal('2.50'))
    Demo(1, NoChange, u'This is a foo', NoChange)


Lost update checking/conflict detection between diff records::

    >>> diff1 = Demo(1, "Bar", sharing.NoChange, Decimal('1.29'))
    >>> diff2 = Demo(1, sharing.NoChange, "This is NOT a foo", Decimal('2.50'))

    >>> diff1 - diff2   # if diff1 is overwritten by diff2, the lost update is:
    Demo(1, NoChange, NoChange, Decimal("1.29"))

    >>> diff2 - diff1   # if diff2 is overwritten by diff1, the lost update is:
    Demo(1, NoChange, NoChange, Decimal("2.50"))

    >>> diff3 = Demo(1, "Bar", sharing.NoChange, sharing.NoChange)
    >>> diff1 - diff3   # if diff1 is overwritten by diff3, the lost update is:
    NoChange

Record addition (second record overwrites fields in first, unless NoChange,
as long as keys match::

    >>> r1 + diff1
    Demo(1, u'Bar', u'This is a foo', Decimal("1.29"))

    >>> r1 + Demo(2, "spam", "wah", sharing.NoChange)
    Traceback (most recent call last):
      ...
    ValueError: Can't add itemNumber 1 to itemNumber 2

You can get a unique key for a record using its ``getKey()`` method.  The
return value is a tuple containing the record type, followed by the values of
the record's key fields, in the order they were defined::

    >>> diff1.getKey()
    (<class 'Demo'>, 1)

    >>> class Demo2(sharing.Record):
    ...     URI         = 'cid:eim.Demo2@osaf.us'
    ...     itemName    = sharing.field(sharing.TextType(size=50))
    ...     itemNumber  = sharing.key(int)
    ...     description = sharing.field(sharing.TextType(size=500))
    ...     price       = sharing.key(sharing.DecimalType(None, 6, 2))

    >>> Demo2(u'blah', 27, u'foobly', Decimal('16.2')).getKey()
    (<class 'Demo2'>, 27, Decimal("16.2"))


Record Sets
-----------

    >>> class R(sharing.Record):
    ...     URI = 'cid:eim.R@osaf.us'
    ...     k = sharing.key(int)
    ...     v = sharing.field(int)

    >>> r1 = R(1, 2)
    >>> r2 = R(1, -2)
    >>> r3 = R(3, 3)

    >>> rs = sharing.RecordSet([r1])

    >>> rs.inclusions == set([r1])
    True
    >>> rs.exclusions == set()
    True

    >>> rs == sharing.RecordSet([r2])
    False
    >>> rs != sharing.RecordSet([r2])
    True
    >>> rs == sharing.RecordSet([r1])
    True
    >>> rs != sharing.RecordSet([r1])
    False

    >>> rs - rs
    RecordSet(set([]), set([]))

    >>> rs+sharing.RecordSet([r3]) == sharing.RecordSet([r1,r3], [])
    True
    >>> rs-sharing.RecordSet([r3]) == sharing.RecordSet([r1],[r3])
    True

    >>> rs+sharing.RecordSet([r2]) == sharing.RecordSet([r2])
    True

    >>> sharing.RecordSet([r2]) + rs == rs
    True

    >>> rs - sharing.RecordSet([r2]) == rs
    True

    >>> rs_old = rs
    >>> rs += sharing.RecordSet([r2])
    >>> rs == sharing.RecordSet([r2])
    True

    >>> rs is rs_old
    True

Record set conflict detection::

    >>> rs_inc1 = sharing.RecordSet([R(1, 2)])
    >>> rs_inc2 = sharing.RecordSet([R(1, -2)])
    >>> rs_exc1 = sharing.RecordSet(exclusions=[R(1, 2)])
    >>> rs_empty = sharing.RecordSet()
    >>> recordsets = [rs_empty, rs_exc1, rs_inc1, rs_inc2]
    >>> names = "Empty", "Exc 1", "Inc 1", "Inc 2"

    >>> for name, base in zip(names, recordsets):
    ...     if name==names[0]:  # print heading
    ...         print "<<<"
    ...         print " "*8+"  ".join(names)
    ...         print " "*8+"  ".join(["-----"]*len(names))
    ...     print name+": ",
    ...     for other in recordsets:
    ...         cfrs = base.conflicts(other)
    ...         print names[recordsets.index(cfrs)]+" ",
    ...
    ...     print   # doctest: +NORMALIZE_WHITESPACE
    <<<
            Empty  Exc 1  Inc 1  Inc 2
            -----  -----  -----  -----
    Empty:  Empty  Empty  Empty  Empty
    Exc 1:  Empty  Empty  Exc 1  Exc 1
    Inc 1:  Empty  Inc 1  Empty  Inc 1
    Inc 2:  Empty  Inc 2  Inc 2  Empty

In the above table, the rows represent a base "diff" recordset, such as
Chandler's local changes during sharing.  The columns represent a second,
overwriting diff (such as Cosmo's changes during sharing).  The result
represents the changes in the base diff that are lost as a result of applying
the overwriting diff.  As you can see, the resulting diff is the same as the
base diff in cases where there is a conflict, and empty otherwise.

(Of course, this truth table is generated using only records with one
changeable field, and having at most one key value.  Real-life recordsets will
be more complex, and the relationships shown above will apply on a per-record
and per-field basis, rather than at the recordset level.)


Filters
-------

Filters are used to suppress the inclusion of selected fields from shared
records.  To define one, you must provide a unique URI, and a human-readable
description (in Unicode) of the filter::

    >>> Reminders = sharing.Filter('cid:reminder-filter@osaf.us', u"Reminders")
    >>> Passwords = sharing.Filter('cid:password-filter@osaf.us', u"Passwords")

    >>> sharing.lookupSchemaURI('cid:reminder-filter@osaf.us')
    Filter('cid:reminder-filter@osaf.us', u'Reminders')

    >>> sharing.lookupSchemaURI('cid:password-filter@osaf.us')
    Filter('cid:password-filter@osaf.us', u'Passwords')


When you define record types, you can provide a list of filters to one or more
fields::

    >>> t50 = sharing.TextType(size=50)
    >>> d62 = sharing.DecimalType(None, 6, 2)
    >>> t500 = sharing.TextType(size=500)

    >>> class SomeType(sharing.Record):
    ...     URI = 'cid:SomeType-for-eim@osaf.us'
    ...     foo = sharing.key(int)
    ...     bar = sharing.field(t50, [Reminders, Passwords])
    ...     baz = sharing.field(d62, [Reminders])
    ...     spam  = sharing.field(t500)
    ...     pin = sharing.field(int, [Passwords])

These fields are then suppressed whenever you take the ``sync_filter()`` of an
applicable record::

    >>> r4 = SomeType(42, u'password reminder', Decimal('3'), u'blah', 2001)
    >>> r4
    SomeType(42, u'password reminder', Decimal("3"), u'blah', 2001)

    >>> Reminders.sync_filter(r4)   # remove other fields
    SomeType(42, NoChange, NoChange, u'blah', 2001)

    >>> Passwords.sync_filter(r4)   # remove Password fields
    SomeType(42, NoChange, Decimal("3"), u'blah', NoChange)

Record types that are not linked to the filter are returned unchanged from
``sync_filter()``::

    >>> Reminders.sync_filter(r1)
    R(1, 2)

    >>> Passwords.sync_filter(r3)
    R(3, 3)

You can also pass ``RecordSet`` instances to ``sync_filter``, and the result is
a new ``RecordSet``::

    >>> r4s = sharing.RecordSet([r4])
    >>> Passwords.sync_filter(r4s)  # doctest: +NORMALIZE_WHITESPACE
    RecordSet(set([SomeType(42, NoChange, Decimal("3"), u'blah', NoChange)]),
              set([]))

But only the ``inclusions`` are filtered, not the ``exclusions``::

    >>> r4s = sharing.RecordSet(exclusions=[r4])
    >>> Passwords.sync_filter(r4s)  # doctest: +NORMALIZE_WHITESPACE
    RecordSet(set([]),
              set([SomeType(42, u'password reminder', Decimal("3"), u'blah',
                   2001)]))

Filter Arithmetic
-----------------

You can add fields to an existing filter using the ``+=`` operator::

    >>> Reminders.sync_filter(r1)
    R(1, 2)

    >>> Reminders += R.v

    >>> Reminders.sync_filter(r1)
    R(1, NoChange)

You can also combined filters using ``+=``.  Normally this will be used by
sharing conduits to construct filters according to the share's filtering
options::

    >>> conduit_filter = sharing.Filter(None, u'Temporary filter')
    >>> conduit_filter += Reminders     # add in active filters for this share
    >>> conduit_filter += Passwords     # (real code would use lookupSchemaURI)

    >>> conduit_filter.sync_filter(r1)
    R(1, NoChange)

    >>> conduit_filter.sync_filter(r4)
    SomeType(42, NoChange, NoChange, u'blah', NoChange)


Notes on Filtering and Sync algorithms::

    Note: We may need a publish_filter() capability if Cosmo can't handle
          missing fields

    for item in changed_items:
        rsNewBase[item.itsUUID] = Recordset(translator.exportItem(item))

    for itemUUID, rs in inbound_diff.items():
        dInbound = rs - rsOldBase.setdefault(itemUUID, empty_rs)    # Cosmo 0.6
        if itemUUID in rsNewBase:
            dLocal = rsNewBase[itemUUID] - rsOldBase[itemUUID]
            dLost[itemUUID] = dLocal - dInbound
            rsNewBase[itemUUID] += dInbound
        translator.processRecords(sync_filter(dInbound)) #import and/or delete
        rsOldBase[itemUUID] += dInbound

    for itemUUID, rs in rsNewBase.items():
        if itemUUID in rsOldBase:
            dOutbound = sync_filter(rs - rsOldBase[itemUUID])
        else:
            dOutbound = publish_filter(rs)
            rsOldBase[itemUUID] = empty_rs
        #send(dOutbound)
        rsOldBase[itemUUID] += dOutbound
        send(rsOldBase[itemUUID])   # Cosmo 0.6


The Translator Framework
========================

A ``sharing.Translator`` is an object that handles importing and exporting of
Chandler items as EIM records.  It must have ``URI`` (string), ``version``
(integer), and ``description`` (unicode) attributes::

    >>> from application import schema
    >>> from osaf import pim

    >>> class DemoTranslator(sharing.Translator):
    ...     """Demonstration translator"""
    ...     URI = "cid:demotranslator@osaf.us"
    ...     version = 1
    ...     description = u"Localized human-readable description here"
    ...
    ...     @Demo.importer
    ...     def import_Demo_record(self, r):
    ...         print "importing Demo record:", r
    ...
    ...     @Demo.deleter
    ...     def delete_Demo_record(self, r):
    ...         print "deleting Demo:", r
    ...
    ...     @R.importer
    ...     def import_R_record(self, r):
    ...         print "importing R record:", r
    ...
    ...     @R.deleter
    ...     def delete_R_record(self, r):
    ...         print "deleting R:", r
    ...
    ...     @sharing.exporter(schema.Item)
    ...     def export_item(self, item):
    ...         print "exporting item"
    ...         yield R(1,2)
    ...
    ...     @sharing.exporter(pim.ContentItem)
    ...     def export_contentitem(self, item):
    ...         print "exporting ContentItem"
    ...         yield R(3,4)

When we support user-defined translator classes, we will probably need to use
either "entry points" or some repository registry to look them up for
importing.  However, once imported, translator classes can be looked up using
the standard ``lookupSchemaURI()`` API::

    >>> sharing.lookupSchemaURI("cid:demotranslator@osaf.us")
    <class 'DemoTranslator'>

The sharing layer creates a new translator instance for each import or export
operation.  The constructor accepts a single argument, a repository view, which
is stored in the ``rv`` attribute::

    >>> from repository.persistence.RepositoryView import NullRepositoryView
    >>> rv = NullRepositoryView(verify=True)  # report errors immediately

    >>> t = DemoTranslator(rv)
    >>> t.rv is rv
    True

(Note: the attribute is called ``rv`` instead of ``itsView`` because translator
instances are *not* stored in the repository; calling it ``itsView`` would
imply it was actually associated with the view in some way.  It's not.)


Exporting (Sharing Layer)
-------------------------

The sharing layer calls a translator instance's  ``startExport()`` and
``finishExport()`` methods at the beginning and end of an export operation.
The default implementations do nothing, although they can be overridden in
subclasses.  ``finishExport()`` must yield or return a (possibly-empty)
sequence of records, while the return value of ``startExport()``, if any,
is ignored.

In between the two calls, ``exportItem()`` can be called zero or more times
to yield EIM records for a given item::

::

    >>> t = DemoTranslator(rv)
    >>> t.startExport()

    >>> list(t.exportItem(pim.ContentItem(itsName="foo", itsParent=rv)))
    exporting item
    exporting ContentItem
    [R(1, 2), R(3, 4)]

    >>> list(t.finishExport())
    []


Importing (Sharing Layer)
-------------------------

The sharing layer calls a translator instance's  ``startImport()`` and
``finishImport()`` methods at the beginning and end of an import operation.
The default implementations do nothing, although they can be overridden in
subclasses.  The return values, if any, are ignored.

In between the two calls, ``importRecords()`` can be called zero or more times
to process a ``RecordSet`` object's inclusions (adds/updates) and exclusions
(deletions).

::

    >>> t = DemoTranslator(rv)
    >>> t.startImport()

    >>> d = Demo(1,"Foo", "This is a foo", Decimal('2.50'))

    >>> t.importRecords(sharing.RecordSet([R(1,2)], [d]))
    importing R record: R(1, 2)
    deleting Demo: Demo(1, u'Foo', u'This is a foo', Decimal("2.50"))

    >>> t.importRecords(sharing.RecordSet([d], [R(1,2)]))
    importing Demo record: Demo(1, u'Foo', u'This is a foo', Decimal("2.50"))
    deleting R: R(1, 2)

    >>> t.finishImport()


Translator Inheritance
----------------------

Importers, deleters, and exporters are inherited by translator subclasses::

    >>> class DemoTranslator2(DemoTranslator):
    ...     """Demonstration translator 2"""
    ...     URI = "cid:demotranslator2@osaf.us"
    ...     version = 1
    ...     description = u"Localized human-readable description here"
    ...
    ...     @Demo.importer
    ...     def import_Demo_record(self, r):
    ...         print "welcome,", r
    ...
    ...     @Demo.deleter
    ...     def delete_Demo_record(self, r):
    ...         print "farewell,", r
    ...
    ...     @sharing.exporter(schema.Item)
    ...     def export_item(self, item):
    ...         print "exporting item"
    ...         yield R(-1, -2)

    >>> t = DemoTranslator2(rv)
    >>> t.startImport()

    >>> t.importRecords(sharing.RecordSet([R(1,2)], [d]))
    importing R record: R(1, 2)
    farewell, Demo(1, u'Foo', u'This is a foo', Decimal("2.50"))

    >>> t.importRecords(sharing.RecordSet([d], [R(1,2)]))
    welcome, Demo(1, u'Foo', u'This is a foo', Decimal("2.50"))
    deleting R: R(1, 2)

    >>> t.finishImport()

    >>> t.startExport()
    >>> list(t.exportItem(rv['foo']))
    exporting item
    exporting ContentItem
    [R(-1, -2), R(3, 4)]

    >>> list(t.finishExport())
    []


TODO: loadItemByUUID
TODO: foreign key refs/ordering
TODO: rewrite this crazy doctest as a parcel dev tutorial & a sharing reference


Defining and Using Field Types
==============================

Custom Types
------------

The most basic kinds of field types can be created using the ``BytesType``,
``TextType``, ``IntType``, ``DateType``, ``DecimalType``, and ``LobType``
constructors::

    >>> my_date = sharing.DateType()
    >>> my_date
    sharing.DateType(None)

Types can be given a unique URI, and they can be looked up by it::

    >>> my_text = sharing.TextType("cid:some_text_type@osaf.us", size=99)
    >>> my_text
    sharing.TextType('cid:some_text_type@osaf.us', 99)

    >>> sharing.typeinfo_for("cid:some_text_type@osaf.us")
    sharing.TextType('cid:some_text_type@osaf.us', 99)

    >>> my_text.uri
    'cid:some_text_type@osaf.us'

    >>> my_text.size
    99

But only one type can exist for a given URI at a given point in time::

    >>> another_text = sharing.TextType("cid:some_text_type@osaf.us", 99)
    Traceback (most recent call last):
      ...
    TypeError: URI 'cid:some_text_type@osaf.us' is already in use

    >>> del my_text     # no conflicting definition now
    >>> another_text = sharing.TextType("cid:some_text_type@osaf.us", 99)


Type Aliasing
-------------

The ``sharing.typedef()`` API lets you register type information for arbitrary
Python objects, so that you can use existing types, kinds, etc. as field types.
For example::

    >>> class my_int(int):
    ...     """This is just a demonstration type"""

    >>> my_int_type = sharing.IntType('cid:my_int_ex@osaf.us')
    >>> sharing.typedef(my_int, my_int_type)

Now, ``my_int`` can be used directly as a field type in a ``sharing.Record``
class, instead of using the ``IntType`` object::

    >>> class DemoRecord(sharing.Record):
    ...     URI = 'cid:eim.DemoRecord@osaf.us'
    ...     an_int = sharing.field(my_int)

    >>> DemoRecord.an_int.type
    <class 'my_int'>

    >>> DemoRecord.an_int.typeinfo
    sharing.IntType('cid:my_int_ex@osaf.us')

You can alias more than one object to the same type, or alias an object to
an already-registered alias::

    >>> class my_int2(int):
    ...     """Another demonstration type"""

    >>> sharing.typedef(my_int2, my_int)
    >>> sharing.typeinfo_for(my_int2) is sharing.typeinfo_for(my_int)
    True

There are also built-in aliases for anonymous versions of the sizeless
primitive types (``IntType``, ``LobType``, and ``DateType``), so you can
use them directly in fields::

    >>> sharing.typeinfo_for(sharing.IntType)
    sharing.IntType(None)

    >>> sharing.typeinfo_for(sharing.LobType)
    sharing.LobType(None)

    >>> sharing.typeinfo_for(sharing.DateType)
    sharing.DateType(None)


Type Conversion
---------------

Because there are only five primitive EIM types (bytes, text, integer,
date/time, and "lob"), it is usually necessary to convert some application-
level data types to the corresponding primitive type.

For example, let's say that an application has a value that is normally
represented as a hexidecimal string, but which for some reason it wants to
transmit as an integer in its sharing records.  The application would need
to define a string converter to turn the hex string into an integer.

So let's define a ``hexint`` type that we can use in field definitions where
we want to be able to supply either integers or hex strings as input when
creating a record.

    >>> hexint = sharing.IntType('cid:hexint_example@osaf.us')

    >>> class HexRecord(sharing.Record):
    ...     URI = 'cid:eim.HexRecord@osaf.us'
    ...     aField = sharing.field(hexint)

By default, there is no converter registered to convert strings to integers,
although there is one for converting integers to integers::

    >>> HexRecord(23)
    HexRecord(23)

    >>> HexRecord("23")
    Traceback (most recent call last):
      ...
    TypeError: No converter registered for values of type <type 'str'>

The ``sharing.add_converter()`` API allows you to register a conversion
function to be used for a particular field or field type::

    >>> sharing.add_converter(hexint, str, lambda v: int(v,16))
    >>> HexRecord("23")
    HexRecord(35)

You can also override the conversion function(s) on a field-by-field basis::

    >>> sharing.add_converter(HexRecord.aField, str, lambda v: int(v,8))
    >>> HexRecord("23")
    HexRecord(19)

XXX Need more default encoders for primitive types; only int->IntType currently
    works


Creating Subtypes
-----------------

Sometimes, it's useful to create a field type by copying an existing type.  The
``sharing.subtype()`` function creates a new type from an existing one.  The
new type will be of the same primitive type, and it will "inherit" any
conversion functions defined for the base type::

    >>> hexint2 = sharing.subtype(hexint)
    >>> hexint2
    sharing.IntType(None)

    >>> sharing.get_converter(hexint2)("23")
    35

New subtypes default to having the same size as their base type, if
applicable, and any extra arguments to ``subtype()`` are passed through to
the appropriate constructor::

    >>> bytes1 = sharing.BytesType(size=55)
    >>> bytes2 = sharing.subtype(bytes1, 'bytes2 uri')
    >>> bytes2
    sharing.BytesType('bytes2 uri', 55)

    >>> dec1 = sharing.DecimalType(None, 9, 3)
    >>> sharing.subtype(dec1, decimal_places = 2)
    sharing.DecimalType(None, 9, 2)
    >>> sharing.subtype(dec1, digits = 7)
    sharing.DecimalType(None, 7, 3)

Note that you can also subtype type aliases::

    >>> sharing.subtype(my_int, 'dummy uri')
    sharing.IntType('dummy uri')


XXX test generation-skipping in converter registration


---------
Internals
---------

TypeInfo instances are immutable once created::

    >>> t = sharing.IntType()
    >>> t.uri = "fhdsfblah"
    Traceback (most recent call last):
      ...
    TypeError: sharing.IntType instances are immutable

Misc. constructor data validation tests::

    >>> sharing.TypeInfo()
    Traceback (most recent call last):
      ...
    TypeError: sharing.TypeInfo is an abstract type; use a subtype

    >>> sharing.SizedType()
    Traceback (most recent call last):
      ...
    TypeError: size must be specified when creating a sharing.SizedType

    >>> sharing.SizedType(size=53)
    Traceback (most recent call last):
      ...
    TypeError: sharing.SizedType is an abstract type; use a subtype

    >>> sharing.BytesType()
    Traceback (most recent call last):
      ...
    TypeError: size must be specified when creating a sharing.BytesType

    >>> sharing.TextType()
    Traceback (most recent call last):
      ...
    TypeError: size must be specified when creating a sharing.TextType

    >>> sharing.DecimalType()
    Traceback (most recent call last):
      ...
    TypeError: digits and decimal_places must be ... sharing.DecimalType

    >>> sharing.DecimalType(None, 3)    # default places of 0
    sharing.DecimalType(None, 3, 0)


No such type::

    >>> sharing.typeinfo_for('xyz:abc')
    Traceback (most recent call last):
      ...
    UnknownType: 'xyz:abc'

Recordtype/field creation and sequence numbers::

    >>> class MyRecord(sharing.Record):
    ...     URI = 'cid:eim.MyRecord@osaf.us'
    ...     f1, f2 = sharing.field(hexint), sharing.field(hexint)

    >>> f1, f2 = MyRecord.f1, MyRecord.f2

    >>> f1.name
    'f1'
    >>> f1.offset
    1
    >>> f2.offset
    2
    >>> f1.owner is MyRecord
    True

    >>> MyRecord.__fields__ == (f1, f2)
    True

    >>> f1.type is hexint
    True
    >>> f1 < f2
    True
    >>> f2 > f1
    True
    >>> f1 != f2
    True
    >>> f1 >= f2
    False

    >>> f2 == f2.seq    # must not be directly comparable to integer
    False

    >>> class MR2(sharing.Record):
    ...     URI = 'cid:eim.MR2@osaf.us'
    ...     f3 = sharing.field(my_int)

    >>> r = MyRecord("23", f2=3)
    >>> r
    MyRecord(35, 3)

    >>> r.f1, r.f2
    (35, 3)

    >>> MR2(27)
    MR2(27)

    >>> sharing.field(27)   # must be a registered type or alias
    Traceback (most recent call last):
      ...
    UnknownType: 27

Verify that the generated constructor code shows up in tracebacks::

    >>> try:
    ...     MR2(42.0)
    ... except:
    ...     import traceback
    ...     tb = traceback.format_exc()

    >>> print tb
    Traceback (most recent call last):
      File ...
        MR2(42.0)
      File "EIM-Generated Constructor for __builtin__.MR2", line 2, in __new__
        f3 = get_converter(cls.f3)(f3)
      ...
    TypeError: No converter registered for values of type <type 'float'>
    <BLANKLINE>

Immutable field attrs::

    >>> sharing.field(my_int).foo = "bar"
    Traceback (most recent call last):
      ...
    AttributeError: 'field' object has no attribute 'foo'

    >>> MyRecord.f1.offset = 16
    Traceback (most recent call last):
      ...
    TypeError: field objects are immutable

Record is dict-less, immutable::

    >>> r.__dict__
    Traceback (most recent call last):
      ...
    AttributeError: 'MyRecord' object has no attribute '__dict__'

    >>> r.f1 = 42
    Traceback (most recent call last):
      ...
    AttributeError: 'MyRecord' object attribute 'f1' is read-only

    >>> r.xxx = 99
    Traceback (most recent call last):
      ...
    AttributeError: 'MyRecord' object has no attribute 'xxx'


Can't subclass an existing record type, or reuse fields in other record types::

    >>> class CantDoThis(MyRecord):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: Record classes cannot be subclassed

    >>> class CantDoThis(sharing.Record):
    ...     URI = 'cid:eim.CantDoThis@osaf.us'
    ...     f3 = MyRecord.f1
    Traceback (most recent call last):
      ...
    TypeError: Can't reuse field 'MyRecord.f1' as 'CantDoThis.f3'

Can't filter a non-record type::

    >>> Passwords.sync_filter(42)
    Traceback (most recent call last):
      ...
    TypeError: Not a Record or RecordSet: 42

Can't add non-field, non-filter to filter::

    >>> Passwords += 42
    Traceback (most recent call last):
      ...
    TypeError: Can't add 42 to Filter

Translators *must* have all required attributes, of the right types, and with
unique URIs::

    >>> class MissingURI(sharing.Translator):
    ...     version = 1
    ...     description = u"Localized human-readable description here"
    Traceback (most recent call last):
      ...
    TypeError: Translator classes must have a `URI` attribute of type `str`

    >>> class MissingVersion(sharing.Translator):
    ...     URI = 'cid:foo@bar.osaf.us'
    ...     description = u"Localized human-readable description here"
    Traceback (most recent call last):
      ...
    TypeError: Translator classes must have a `version` attribute of type `int`

    >>> class MissingDescr(sharing.Translator):
    ...     URI = 'cid:foo@bar.osaf.us'
    ...     version = 42
    Traceback (most recent call last):
      ...
    TypeError: ... must have a `description` attribute of type `unicode`

    >>> class DupeURI(sharing.Translator):
    ...     URI = 'cid:eim.R@osaf.us'   # already in use above
    ...     version = 1
    ...     description = u"Localized human-readable description here"
    Traceback (most recent call last):
      ...
    TypeError: URI 'cid:eim.R@osaf.us' is already in use

More than one import or delete type can be declared for a given function::

    >>> class Testlator1(sharing.Translator):
    ...     URI = 'cid:testlator1@osaf.us'   # already in use above
    ...     version = 1
    ...     description = u"Blah"
    ...
    ...     @R.importer
    ...     @MyRecord.importer
    ...     def import_something(self, record):
    ...         print "yo!", record
    ...
    ...     @R.deleter
    ...     @MyRecord.deleter
    ...     def delete_something(self, record):
    ...         print "hasta la vista,", record

    >>> t = Testlator1(rv)
    >>> t.startImport()
    >>> t.importRecords(sharing.RecordSet([R(1,2)], [MyRecord(3,4)]))
    yo! R(1, 2)
    hasta la vista, MyRecord(3, 4)

    >>> t.finishImport()

But it's an error to define more than one importer or deleter for a given type
in a given translator class::

    >>> class Testlator2(sharing.Translator):
    ...     URI = 'cid:testlator2@osaf.us'   # already in use above
    ...     version = 1
    ...     description = u"Blah"
    ...
    ...     @R.importer
    ...     def import_something(self, record):
    ...         print "yo!", record
    ...
    ...     @R.importer
    ...     def extra_import(self, record):
    ...         print "howzit,", record
    Traceback (most recent call last):
      ...
    TypeError: Multiple importers defined for <class 'R'> in <class 'Testlator2'>

    >>> class Testlator3(sharing.Translator):
    ...     URI = 'cid:testlator3@osaf.us'   # already in use above
    ...     version = 1
    ...     description = u"Blah"
    ...
    ...     @R.deleter
    ...     def del_something(self, record):
    ...         print "adios!", record
    ...
    ...     @R.deleter
    ...     def extra_del(self, record):
    ...         print "see ya,", record
    Traceback (most recent call last):
      ...
    TypeError: Multiple deleters defined for <class 'R'> in <class 'Testlator3'>

    >>> class Testlator4(sharing.Translator):
    ...     URI = 'cid:testlator4@osaf.us'   # already in use above
    ...     version = 1
    ...     description = u"Blah"
    ...
    ...     @sharing.exporter(schema.Item, pim.ContentItem)
    ...     def export_something(self, record):
    ...         return []
    ...
    ...     @sharing.exporter(schema.Item)
    ...     def extra_export(self, record):
    ...         return []
    Traceback (most recent call last):
      ...
    TypeError: Multiple exporters defined for <class '...Item'> in <class 'Testlator4'>


