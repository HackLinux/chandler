
Serializing Values
------------------


First define a record type::

    >>> from application import schema
    >>> from osaf import sharing, pim
    >>> from osaf.sharing import ( eimml, recordset_conduit, State, getFilter,
    ...     Missing, RecordSet as rs, NoChange as nc )
    >>> from PyICU import ICUtzinfo
    >>> import datetime, decimal
    >>> from repository.persistence.RepositoryView import NullRepositoryView
    >>> rv = NullRepositoryView()
    >>> class TestRecord(sharing.Record):
    ...     URI = 'cid:TestRecord@osaf.us'
    ...     textField = sharing.field(sharing.TextType(size=100))
    ...     decimalField = sharing.field(sharing.DecimalType(digits=11,
    ...                                  decimal_places=2))
    ...     dateField = sharing.field(sharing.DateType)


Translate text values::

    >>> value = eimml.deserializeValue(TestRecord.textField.typeinfo, 'xyzzy')
    >>> value
    'xyzzy'
    >>> eimml.serializeValue(TestRecord.textField.typeinfo, value)
    ('xyzzy', 'text')


Translate decimal values::

    >>> value = eimml.deserializeValue(TestRecord.decimalField.typeinfo, '123.45')
    >>> value
    Decimal("123.45")
    >>> eimml.serializeValue(TestRecord.decimalField.typeinfo, value)
    ('123.45', 'decimal')


Translate datetime values::

    >>> value = eimml.deserializeValue(TestRecord.dateField.typeinfo,
    ... '2007-01-30T15:45:30.098593-08:00')
    >>> value
    datetime.datetime(2007, 1, 30, 15, 45, 30, 98593, tzinfo=<ICUtzinfo: Etc/GMT+8>)
    >>> eimml.serializeValue(TestRecord.dateField.typeinfo, value)
    ('2007-01-30T15:45:30.098593-08:00', 'datetime')

TODO: int, lob, bytes


Serialize and deserialize entire record sets using EIMMLSerializerLite::

    >>> sampleLite = '''<?xml version="1.0" encoding="UTF-8"?>
    ...
    ... <eim:collection a="1" b="2" uuid="9501de14-1dc9-40d4-a7d4-f289feff8214"
    ... xmlns:eim="http://osafoundation.org/eim/0"
    ... xmlns:item="http://osafoundation.org/eim/item/0"
    ... xmlns:modby="http://osafoundation.org/eim/modifiedBy/0"
    ... xmlns:event="http://osafoundation.org/eim/event/0"
    ... xmlns:note="http://osafoundation.org/eim/note/0">
    ... <eim:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214">
    ...    <item:record uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" title="Welcome to Cosmo" triage="100 123456789.12 1" createdOn="1164803131" />
    ...    <modby:record uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" userid="foo@example.com" timestamp="1164803132" />
    ...    <note:record uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" body="This is the body" icalUid="1e2d48c0-d66b-494c-bb33-c3d75a1ba66b" reminderTime="1169163900" />
    ...    <event:record uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" dtstart="20061130T140000" dtend="20061130T150000" location="San Jose" rrule="FREQ=WEEKLY" status="CONFIRMED" />
    ... </eim:recordset>
    ... </eim:collection>'''

    >>> expectedRecordSets = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'100 123456789.12 1', decimal.Decimal("1164803131")), sharing.model.ModifiedByRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'foo@example.com', decimal.Decimal("1164803132")), sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', decimal.Decimal('1169163900')), sharing.model.EventRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'20061130T140000', u'20061130T150000', u'San Jose', u'FREQ=WEEKLY', None, None, None, u'CONFIRMED', None, None)])}

    >>> recordSets, extra = eimml.EIMMLSerializerLite.deserialize(sampleLite)
    >>> recordSets == expectedRecordSets
    True
    >>> extra
    {'a': '1', 'b': '2', 'uuid': '9501de14-1dc9-40d4-a7d4-f289feff8214'}

    >>> text = eimml.EIMMLSerializerLite.serialize(recordSets, name="foo")

    >>> recordSets, extra = eimml.EIMMLSerializerLite.deserialize(text)
    >>> recordSets == expectedRecordSets
    True

    >>> extra
    {'name': 'foo'}


Serialize and deserialize entire record sets using EIMMLSerializer::


    >>> sample = '''<?xml version='1.0' encoding='UTF-8'?>
    ...
    ... <eim:collection name="foo" xmlns:eim="http://osafoundation.org/eim/0">
    ...   <eim:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214">
    ...     <item:record xmlns:item="http://osafoundation.org/eim/item/0">
    ...       <item:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></item:uuid>
    ...       <item:title eim:type="text"><![CDATA[Welcome to Cosmo]]></item:title>
    ...       <item:triage eim:type="text">100 123456789.12 1</item:triage>
    ...       <item:createdOn eim:type="decimal"><![CDATA[1164803131]]></item:createdOn>
    ...     </item:record>
    ...     <modby:record xmlns:modby="http://osafoundation.org/eim/modifiedBy/0">
    ...       <modby:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></modby:uuid>
    ...       <modby:userid eim:type="text"><![CDATA[foo@example.com]]></modby:userid>
    ...       <modby:timestamp eim:type="decimal"><![CDATA[1164803132]]></modby:timestamp>
    ...     </modby:record>
    ...     <note:record xmlns:note="http://osafoundation.org/eim/note/0">
    ...       <note:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></note:uuid>
    ...       <note:body eim:type="clob"><![CDATA[This is the body]]></note:body>
    ...       <note:icalUid eim:type="text"><![CDATA[1e2d48c0-d66b-494c-bb33-c3d75a1ba66b]]></note:icalUid>
    ...       <note:reminderTime eim:type="decimal"><![CDATA[1169163900]]></note:reminderTime>
    ...     </note:record>
    ...     <event:record xmlns:event="http://osafoundation.org/eim/event/0">
    ...       <event:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></event:uuid>
    ...       <event:dtstart eim:type="text"><![CDATA[20061130T140000]]></event:dtstart>
    ...       <event:dtend eim:type="text"><![CDATA[20061130T150000]]></event:dtend>
    ...       <event:location eim:type="text"><![CDATA[San Jose]]></event:location>
    ...       <event:rrule eim:type="text"><![CDATA[FREQ=WEEKLY]]></event:rrule>
    ...       <event:exrule eim:type="text" />
    ...       <event:rdate eim:type="text" />
    ...       <event:exdate eim:type="text" />
    ...       <event:status eim:type="text"><![CDATA[CONFIRMED]]></event:status>
    ...       <event:icalParameters eim:type="text" />
    ...       <event:icalProperties eim:type="text" />
    ...     </event:record>
    ...   </eim:recordset>
    ... </eim:collection>'''

    >>> recordSets, extra = eimml.EIMMLSerializer.deserialize(sample)
    >>> recordSets == expectedRecordSets
    True

    >>> extra
    {'name': 'foo'}

    >>> text = eimml.EIMMLSerializer.serialize(recordSets, name="foo")

    >>> recordSets, extra = eimml.EIMMLSerializer.deserialize(text)
    >>> recordSets == expectedRecordSets
    True

    >>> extra
    {'name': 'foo'}


Fields with empty strings are serialized with an empty="true" attribute on
their element::

    >>> records = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', '', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', decimal.Decimal('1169163900'))])}
    >>> text = eimml.EIMMLSerializer.serialize(records)
    >>> text
    '<?xml version=\'1.0\' encoding=\'UTF-8\'?><ns0:collection xmlns:ns0="http://osafoundation.org/eim/0"><ns0:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214"><ns1:record xmlns:ns1="http://osafoundation.org/eim/note/0"><ns1:uuid ns0:key="true" ns0:type="text">8501de14-1dc9-40d4-a7d4-f289feff8214</ns1:uuid><ns1:body empty="true" ns0:type="clob" /><ns1:icalUid ns0:type="text">1e2d48c0-d66b-494c-bb33-c3d75a1ba66b</ns1:icalUid><ns1:reminderTime ns0:type="decimal">1169163900</ns1:reminderTime></ns1:record></ns0:recordset></ns0:collection>'
    >>> newRecords, extra = eimml.EIMMLSerializer.deserialize(text)
    >>> records == newRecords
    True

Any records in a recordset's exclusions are serialized as deletions::

    >>> recordDeletion = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs(set([]), set([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'100 123456789.12 1', decimal.Decimal("1164803131"))]))}
    >>> text = eimml.EIMMLSerializer.serialize(recordDeletion)
    >>> text
    '<?xml version=\'1.0\' encoding=\'UTF-8\'?><ns0:collection xmlns:ns0="http://osafoundation.org/eim/0"><ns0:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214"><ns1:record ns0:deleted="true" xmlns:ns1="http://osafoundation.org/eim/item/0"><ns1:uuid ns0:key="true" ns0:type="text">8501de14-1dc9-40d4-a7d4-f289feff8214</ns1:uuid></ns1:record></ns0:recordset></ns0:collection>'

To indicate that item has been deleted, pass None instead of a recordset::

    >>> itemDeletion = { '8501de14-1dc9-40d4-a7d4-f289feff8214' : None }
    >>> text = eimml.EIMMLSerializer.serialize(itemDeletion)
    >>> text
    '<?xml version=\'1.0\' encoding=\'UTF-8\'?><ns0:collection xmlns:ns0="http://osafoundation.org/eim/0"><ns0:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" ns0:deleted="true" /></ns0:collection>'



There is a special value, Missing, which gets serialized as missing="true"::

    >>> missing = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', Missing, u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', decimal.Decimal('1169163900'))])}
    >>> text = eimml.EIMMLSerializer.serialize(missing)
    >>> imported, extra = eimml.EIMMLSerializer.deserialize(text)
    >>> imported
    {'8501de14-1dc9-40d4-a7d4-f289feff8214': RecordSet(set([NoteRecord(u'8501de14-1dc9-40d4-a7d4-f289feff8214', Missing, u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', Decimal("1169163900"))]), set([]))}


Inmemory Mock Cosmo
-------------------

You can "send" a recordset::

    >>> conduit = recordset_conduit.InMemoryDiffRecordSetConduit(itsView=rv,
    ...     shareName="test1", serializer=eimml.EIMMLSerializerLite)
    >>> conduit.put(sampleLite)
    >>> conduit.syncToken
    '1'

If you don't use the previous token, you'll get a failure::

    >>> conduit.syncToken = '42'
    >>> conduit.put(sampleLite)
    Traceback (most recent call last):
    ...
    TokenMismatch: 42 != 1

The token changes whenever you modify the collection::

    >>> conduit.syncToken = '1'
    >>> conduit.put(sampleLite)
    >>> conduit.syncToken
    '2'

Send a new item::

    >>> text = '''<?xml version="1.0" encoding="UTF-8"?>
    ...
    ... <eim:records
    ... xmlns:eim="http://osafoundation.org/eim/0"
    ... xmlns:item="http://osafoundation.org/eim/item/0"
    ... xmlns:modby="http://osafoundation.org/eim/modifiedBy/0"
    ... xmlns:event="http://osafoundation.org/eim/event/0"
    ... xmlns:note="http://osafoundation.org/eim/note/0">
    ... <eim:recordset uuid="9501de14-1dc9-40d4-a7d4-f289feff8214">
    ...    <item:record uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" title="Welcome to Cosmo" triage="100 123456789.12 1" createdOn ="1164803131" />
    ...    <modby:record uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" userid="foo@example.com" timestamp ="1164803132" />
    ...    <note:record uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" body="This is the body" icalUid="1e2d48c0-d66b-494c-bb33-c3d75a1ba66b" reminderTime="1169163900" />
    ...    <event:record uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" dtstart="20061130T140000" dtend="20061130T150000" rrule="FREQ=WEEKLY" status="CONFIRMED" />
    ... </eim:recordset>
    ... </eim:records>'''

    >>> conduit.put(text)
    >>> conduit.syncToken
    '3'

Doing a "get" with the most recent token returns no changes::

    >>> text = conduit.get()
    >>> conduit.syncToken
    '3'
    >>> text
    '<?xml version=\'1.0\' encoding=\'UTF-8\'?><ns0:collection uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" xmlns:ns0="http://osafoundation.org/eim/0" />'

You can ask for recordsets that have been updated since a previous token was
created::

    >>> conduit.syncToken = '1'
    >>> text = conduit.get()
    >>> conduit.syncToken
    '3'
    >>> expectedRecordSets = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'100 123456789.12 1', decimal.Decimal("1164803131")), sharing.model.ModifiedByRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'foo@example.com', decimal.Decimal("1164803132")), sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', decimal.Decimal('1169163900')), sharing.model.EventRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'20061130T140000', u'20061130T150000', u'San Jose', u'FREQ=WEEKLY', None, None, None, u'CONFIRMED', None, None)]), '9501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.ItemRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'100 123456789.12 1', decimal.Decimal("1164803131")), sharing.model.ModifiedByRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', 'foo@example.com', decimal.Decimal("1164803132")), sharing.model.NoteRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', decimal.Decimal('1169163900')), sharing.model.EventRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', u'20061130T140000', u'20061130T150000', None, u'FREQ=WEEKLY', None, None, None, u'CONFIRMED', None, None)]) }
    >>> recordSets, extra = eimml.EIMMLSerializerLite.deserialize(text)
    >>> recordSets == expectedRecordSets
    True





Merging RecordSets
------------------

The RecordSetConduit class has a merge method which will compare inbound
and outbound changes, merge the non-overlapping changes, and return the
set of records to send outbound, the set of records to apply locally, and
the inbound changes that are pending due to conflict::

    >>> empty = rs()

    >>> barFilter = sharing.Filter('cid:bar-filter@osaf.us', u"Bars")
    >>> bazFilter = sharing.Filter('cid:baz-filter@osaf.us', u"Bazzes")

    >>> import osaf.sharing
    >>> __name__ = "osaf.sharing"
    >>> class Demo(sharing.Record):
    ...     URI = 'cid:eim.test.demo-record@osaf.us'
    ...     foo = sharing.key(int)
    ...     bar = sharing.field(int, [barFilter])
    ...     baz = sharing.field(int, [bazFilter])
    >>> osaf.sharing.Demo = Demo

    >>> state = State(itsView=rv)

Verify the state is empty
    >>> state
    State(RecordSet(set([]), set([])), RecordSet(set([]), set([])))

Test a no-op (no inbound nor outbound changes)::

    >>> state.merge(empty, empty)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

Verify the state is still empty
    >>> state
    State(RecordSet(set([]), set([])), RecordSet(set([]), set([])))

Merge a local addition with no inbound changes::

    >>> state.merge(rs([Demo(1, 1, 1)]), empty)
    (RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

Verify the state has been updated::

    >>> state
    State(RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([]), set([])))


Merge in an inbound change (no outbound changes)::

    >>> state.merge(rs([Demo(1, 1, 1)]), rs(set([Demo(1, 1, 2)])))
    (RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 2)]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 1, 2)]), set([])), RecordSet(set([]), set([])))


Merge non-overlapping inbound and outbound changes::

    >>> state.merge(rs([Demo(1, 3, 2)]), rs([Demo(1, 1, 3)]))
    (RecordSet(set([Demo(1, 3, NoChange)]), set([])), RecordSet(set([Demo(1, NoChange, 3)]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 3, 3)]), set([])), RecordSet(set([]), set([])))


Merge overlapping and non-overlapping inbound and outbound changes, resulting
in pending inbound changes::

    >>> state.merge(rs([Demo(1, 4, 4)]), rs([Demo(1, 5, nc)]))
    (RecordSet(set([Demo(1, NoChange, 4)]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 3, 4)]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))


With pending changes, non-conflicting local modifications can still go out::

    >>> state.merge(rs([Demo(1, 4, 5)]))
    (RecordSet(set([Demo(1, NoChange, 5)]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 3, 5)]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))


See that a pending change can disappear due to a later inbound change:

    >>> state.merge(rs([Demo(1, 4, 5)]), rs([Demo(1, 4, 5)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 5)]), set([])), RecordSet(set([]), set([])))


Merge only overlapping inbound and outbound changes::

    >>> state.merge(rs([Demo(1, 4, 6)]), rs([Demo(1, 4, 7)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 7)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 5)]), set([])), RecordSet(set([Demo(1, NoChange, 7)]), set([])))


Add in a filter, make a local change and no inbound changes::

    >>> filter = getFilter(['cid:bar-filter@osaf.us'])
    >>> state.merge(rs([Demo(1, 6, 8)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 7)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 5)]), set([])), RecordSet(set([Demo(1, NoChange, 7)]), set([])))


Even though we locally modified the 'bar' field, it is not sent because of
the filter.  Even though we locally modified the 'baz' field, since there is
an outstanding pending change it is also not sent.

See that a pending change can disappear due to a later outbound change:

    >>> state.merge(rs([Demo(1, 6, 7)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 7)]), set([])), RecordSet(set([]), set([])))


There can be multiple filters in effect; note how we locally change both fields
yet send nothing, and the agreed upon state doesn't change::

    >>> filter = getFilter(['cid:bar-filter@osaf.us', 'cid:baz-filter@osaf.us'])
    >>> state.merge(rs([Demo(1, 7, 8)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 7)]), set([])), RecordSet(set([]), set([])))


Verify that inbound changes to filtered fields are not applied locally, yet
unfiltered inbound changes are applied::

    >>> filter = getFilter(['cid:bar-filter@osaf.us'])
    >>> state.merge(rs([Demo(1, 7, 8)]), rs([Demo(1, 5, 8)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 5, 8)]), set([])), RecordSet(set([]), set([])))


Verify that inbound and outbound changes to a filtered field is not considered
a conflict::

    >>> state.merge(rs([Demo(1, 8, 9)]), rs([Demo(1, 9, 9)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 9, 9)]), set([])), RecordSet(set([]), set([])))


Verify that conflicts can still be detected when at least one conflicting
field is not filtered::

    >>> state.merge(rs([Demo(1, 9, 10)]), rs([Demo(1, 10, 11)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 11)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 10, 9)]), set([])), RecordSet(set([Demo(1, NoChange, 11)]), set([])))


Start over, to test that when a filter is removed, the local change that was
hiding behind the filter is now sent::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)
    >>> filter = getFilter(['cid:bar-filter@osaf.us'])
    >>> state.merge(rs([Demo(1, 2, 2)]), rs([Demo(1, 3, nc)]), filter=filter)
    (RecordSet(set([Demo(1, NoChange, 2)]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 3, 2)]), set([])), RecordSet(set([]), set([])))

Note how the agreed state reflects the external change above.  Now remove the
filter and merge::

    >>> state.merge(rs([Demo(1, 2, 2)]))
    (RecordSet(set([Demo(1, 2, NoChange)]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 2, 2)]), set([])), RecordSet(set([]), set([])))

See how the local change finally got sent out above.


Start over, to test that local deletions get sent::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)

    >>> state.merge(empty)
    (RecordSet(set([]), set([Demo(1, 1, 1)])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))



Start over, to test that remote deletions get applied::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)
    >>> state.merge(rs([Demo(1, 1, 1)]), rs([], [Demo(1, Missing, Missing)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([Demo(1, 1, 1)])), RecordSet(set([]), set([])))



Start over, to test that local changes and remote deletions get detected::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)
    >>> state.merge(rs([Demo(1, 2, 2)]), rs([], [Demo(1, Missing, Missing)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([Demo(1, 1, 1)])))

    >>> state
    State(RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([]), set([Demo(1, 1, 1)])))


Start over, to test that local deletions and remote changes get detected::


    >>> state.set(rs(set([Demo(1,1,1)])), empty)
    >>> state.merge(empty, rs([Demo(1, 2, 2)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 2, 2)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([Demo(1, 2, 2)]), set([])))







Start over, adding two records (one of a new record type)::

    >>> class Demo2(sharing.Record):
    ...     URI = 'cid:eim.test.demo2-record@osaf.us'
    ...     foo = sharing.key(int)
    ...     bar = sharing.field(int, [barFilter])
    ...     baz = sharing.field(int, [bazFilter])
    >>> osaf.sharing.Demo2 = Demo2

    >>> state.set(rs(set([Demo(1,1,1), Demo2(1,2,2)])), empty)

...now remove the Demo(1,1,1), and the result of the merge will be that we
will send a deletion for that record::

    >>> state.merge(rs([Demo2(1, 2, 2)]))
    (RecordSet(set([]), set([Demo(1, 1, 1)])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo2(1, 2, 2)]), set([])), RecordSet(set([]), set([])))


If a record is removed inbound and outbound, that is not a conflict.  Note
that a double-deletion results in an unnecessary record deletion in toApply,
but record adding and deleting need to be idempotent anyway, so it's ok::

    >>> state.merge(empty, empty)
    (RecordSet(set([]), set([Demo2(1, 2, 2)])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([]), set([])), RecordSet(set([]), set([])))




Start over, with a filter this time from the start::

    >>> filter = getFilter(['cid:bar-filter@osaf.us'])
    >>> state.set(empty, empty)

Merge a local addition with no inbound changes; note that the outbound
record has a NoChange value on the filtered field::

    >>> state.merge(rs([Demo(1, 1, 1)]), filter=filter)
    (RecordSet(set([Demo(1, NoChange, 1)]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))





Make sure Missing values can be merged::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)
    >>> state.merge(rs([Demo(1, Missing, 2)]))
    (RecordSet(set([Demo(1, Missing, 2)]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, Missing, 2)]), set([])), RecordSet(set([]), set([])))

    >>> state.merge(rs([Demo(1, Missing, 2)]), rs([Demo(1, 2, Missing)]))
    (RecordSet(set([]), set([])), RecordSet(set([Demo(1, 2, Missing)]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 2, Missing)]), set([])), RecordSet(set([]), set([])))

    >>> state.merge(rs([Demo(1, Missing, 2)]), rs([Demo(1, 3, nc)]))
    (RecordSet(set([Demo(1, NoChange, 2)]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 3, NoChange)]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 2, 2)]), set([])), RecordSet(set([Demo(1, 3, NoChange)]), set([])))



Itemcentric Sharing
-------------------

Items can be shared with a peer without using a persistent Share/Conduit.
The sharing package provides methods for translating items to EIMML and
back.

    >>> rv0 = NullRepositoryView()
    >>> rv1 = NullRepositoryView()
    >>> item0 = pim.Note(itsView=rv0, displayName="test displayName",
    ...     body="test body", triageStatus=pim.TriageEnum.later)
    >>> uuid = item0.itsUUID.str16()
    >>> not pim.has_stamp(item0, sharing.SharedItem)
    True

    >>> pje = schema.Item(itsView=rv0)
    >>> morgen = schema.Item(itsView=rv1)

An item is serialized to EIMML using the outbound method.  The first
argument is a list of items which identifies the peer(s) we're
sharing with; the sharing package doesn't care what this item is;
it could be a Contact item, or email address item, etc., as long
as it's a persistent Chandler item.

    >>> text = sharing.outbound([pje], item0)

Sharing an item this way automatically stamps the item as SharedItem.

    >>> pim.has_stamp(item0, sharing.SharedItem)
    True

An item without conflicts has no SharedItem.conflictingStates attribute::

    >>> hasattr(sharing.SharedItem(item0), "conflictingStates")
    False

An item is imported via the inbound method.

    >>> item1 = sharing.inbound(morgen, text)
    >>> item1 is not None
    True
    >>> pim.has_stamp(item1, sharing.SharedItem)
    True

    >>> item1.displayName
    u'test displayName'

    >>> item1.body
    u'test body'

    >>> item1.triageStatus
    TriageEnum.later

Send changes back

    >>> item1.triageStatus = pim.TriageEnum.now
    >>> text = sharing.outbound([morgen], item1)
    >>> item0 = sharing.inbound(pje, text)
    >>> item0.triageStatus
    TriageEnum.now

You can quickly see if an item has conflicts by checking for the existence of
the 'conflictingStates' attribute::

    >>> shared0 = sharing.SharedItem(item0)
    >>> hasattr(shared0, 'conflictingStates')
    False

    >>> shared1 = sharing.SharedItem(item1)
    >>> hasattr(shared1, 'conflictingStates')
    False

Cause a conflict::

    >>> item0.displayName = u'changed by morgen'
    >>> item1.displayName = u'changed by pje'
    >>> text = sharing.outbound([pje], item0)
    >>> item1 = sharing.inbound(morgen, text)

See if a conflict exists for this item::

    >>> hasattr(shared1, 'conflictingStates')
    True

Get the list of conflicts::

    >>> list(shared1.getConflicts())
    [title : changed by morgen]

A conflict has two attributes that the UI is going to care about, "field" and
"value".  At the moment, "field" is always the string "Something", and "value"
is simply a dumb string conversion of the conflicting recordset.  Soon we will
break out each conflicting field into its own Conflict object that can be
applied or discarded independently.


You can apply() a conflict, which goes ahead and applies those pending changes
to the item::

    >>> item1.displayName
    u'changed by pje'

    >>> for conflict in shared1.getConflicts():
    ...     conflict.apply()

Verify the pending change was applied::

    >>> item1.displayName
    u'changed by morgen'

Once applied, conflicts go away::

    >>> hasattr(shared1, 'conflictingStates')
    False
    >>> list(shared1.getConflicts())
    []

Cause a conflict again::

    >>> item0.displayName = u'changed again by morgen'
    >>> item1.displayName = u'changed again by pje'
    >>> text = sharing.outbound([pje], item0)
    >>> item1 = sharing.inbound(morgen, text)
    >>> list(shared1.getConflicts())
    [title : changed again by morgen]

This time discard the conflict::

    >>> for conflict in shared1.getConflicts():
    ...     conflict.discard()

Again, the conflicts are gone::

    >>> hasattr(shared1, 'conflictingStates')
    False
    >>> list(shared1.getConflicts())
    []
