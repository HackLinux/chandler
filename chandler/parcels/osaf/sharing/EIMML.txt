
Serializing Values
------------------


First define a record type::

    >>> from osaf import sharing
    >>> from osaf.sharing import ( eimml, recordset_conduit,
    ...                            RecordSet as rs, NoChange as nc )
    >>> from PyICU import ICUtzinfo
    >>> import datetime, decimal
    >>> from repository.persistence.RepositoryView import NullRepositoryView
    >>> rv = NullRepositoryView()
    >>> class TestRecord(sharing.Record):
    ...     URI = 'cid:TestRecord@osaf.us'
    ...     textField = sharing.field(sharing.TextType(size=100))
    ...     decimalField = sharing.field(sharing.DecimalType(digits=11,
    ...                                  decimal_places=2))
    ...     dateField = sharing.field(sharing.DateType)


Translate text values::

    >>> value = eimml.deserializeValue(TestRecord.textField.typeinfo, 'xyzzy')
    >>> value
    'xyzzy'
    >>> eimml.serializeValue(TestRecord.textField.typeinfo, value)
    'xyzzy'


Translate decimal values::

    >>> value = eimml.deserializeValue(TestRecord.decimalField.typeinfo, '123.45')
    >>> value
    Decimal("123.45")
    >>> eimml.serializeValue(TestRecord.decimalField.typeinfo, value)
    '123.45'


Translate datetime values::

    >>> value = eimml.deserializeValue(TestRecord.decimalField.typeinfo, '123.45')
    >>> value
    Decimal("123.45")
    >>> eimml.serializeValue(TestRecord.decimalField.typeinfo, value)
    '123.45'


TODO: int, lob, bytes


Serialize and deserialize entire record sets using EIMMLSerializerLite::

    >>> sampleLite = '''<?xml version="1.0" encoding="UTF-8"?>
    ...
    ... <eim:records
    ... xmlns:eim="http://osafoundation.org/eim"
    ... xmlns:item="http://osafoundation.org/eim/item"
    ... xmlns:event="http://osafoundation.org/eim/event"
    ... xmlns:note="http://osafoundation.org/eim/note">
    ... <eim:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214">
    ...    <item:record uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" title="Welcome to Cosmo" triageStatus="now" triageStatusChanged="123456789.12" lastModifiedBy="foo@example.com" createdOn="1164803131" />
    ...    <note:record uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" body="This is the body" icaluid="1e2d48c0-d66b-494c-bb33-c3d75a1ba66b" reminderTime="1169163900" />
    ...    <event:record uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" dtstart="20061130T140000" dtend="20061130T150000" location="San Jose" rrule="FREQ=WEEKLY" status="CONFIRMED" />
    ... </eim:recordset>
    ... </eim:records>'''

    >>> expectedRecordSets = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'now', decimal.Decimal("123456789.12"), u'foo@example.com', decimal.Decimal("1164803131")), sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', decimal.Decimal('1169163900')), sharing.model.EventRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'20061130T140000', u'20061130T150000', None, u'San Jose', u'FREQ=WEEKLY', None, None, None, u'CONFIRMED')])}

    >>> recordSets = eimml.EIMMLSerializerLite.deserialize(sampleLite)
    >>> recordSets == expectedRecordSets
    True

    >>> text = eimml.EIMMLSerializerLite.serialize(recordSets)

    >>> recordSets = eimml.EIMMLSerializerLite.deserialize(text)
    >>> recordSets == expectedRecordSets
    True


Serialize and deserialize entire record sets using EIMMLSerializer::

    >>> sample = '''<?xml version='1.0' encoding='UTF-8'?>
    ...
    ... <eim:records xmlns:eim="http://osafoundation.org/eim">
    ...   <eim:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214">
    ...     <item:record xmlns:item="http://osafoundation.org/eim/item">
    ...       <item:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></item:uuid>
    ...       <item:title eim:type="text"><![CDATA[Welcome to Cosmo]]></item:title>
    ...       <item:triageStatus eim:type="text"><![CDATA[now]]></item:triageStatus>
    ...       <item:triageStatusChanged eim:type="decimal"><![CDATA[123456789.12]]></item:triageStatusChanged>
    ...       <item:lastModifiedBy eim:type="text"><![CDATA[foo@example.com]]></item:lastModifiedBy>
    ...       <item:createdOn eim:type="decimal"><![CDATA[1164803131]]></item:createdOn>
    ...     </item:record>
    ...     <note:record xmlns:note="http://osafoundation.org/eim/note">
    ...       <note:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></note:uuid>
    ...       <note:body eim:type="clob"><![CDATA[This is the body]]></note:body>
    ...       <note:icaluid eim:type="text"><![CDATA[1e2d48c0-d66b-494c-bb33-c3d75a1ba66b]]></note:icaluid>
    ...       <note:reminderTime eim:type="decimal"><![CDATA[1169163900]]></note:reminderTime>
    ...     </note:record>
    ...     <event:record xmlns:event="http://osafoundation.org/eim/event">
    ...       <event:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></event:uuid>
    ...       <event:dtstart eim:type="text"><![CDATA[20061130T140000]]></event:dtstart>
    ...       <event:dtend eim:type="text"><![CDATA[20061130T150000]]></event:dtend>
    ...       <event:location eim:type="text"><![CDATA[San Jose]]></event:location>
    ...       <event:rrule eim:type="text"><![CDATA[FREQ=WEEKLY]]></event:rrule>
    ...       <event:exrule eim:type="text" />
    ...       <event:rdate eim:type="text" />
    ...       <event:exdate eim:type="text" />
    ...       <event:recurrenceId eim:type="text" />
    ...       <event:status eim:type="text"><![CDATA[CONFIRMED]]></event:status>
    ...     </event:record>
    ...   </eim:recordset>
    ... </eim:records>'''

    >>> recordSets = eimml.EIMMLSerializer.deserialize(sample)
    >>> recordSets == expectedRecordSets
    True

    >>> text = eimml.EIMMLSerializer.serialize(recordSets)

    >>> recordSets = eimml.EIMMLSerializer.deserialize(text)
    >>> recordSets == expectedRecordSets
    True

Any records in a recordset's exclusions are serialized as deletions::

    >>> recordDeletion = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs(set([]), set([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'now', decimal.Decimal("123456789.12"), u'foo@example.com', decimal.Decimal("1164803131"))]))}
    >>> text = eimml.EIMMLSerializer.serialize(recordDeletion)
    >>> text == '<ns0:records xmlns:ns0="http://osafoundation.org/eim"><ns0:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214"><ns1:record deleted="true" xmlns:ns1="http://osafoundation.org/eim/item"><ns1:uuid key="true">8501de14-1dc9-40d4-a7d4-f289feff8214</ns1:uuid></ns1:record></ns0:recordset></ns0:records>'
    True

To indicate that item has been deleted, pass None instead of a recordset::

    >>> itemDeletion = { '8501de14-1dc9-40d4-a7d4-f289feff8214' : None }
    >>> text = eimml.EIMMLSerializer.serialize(itemDeletion)
    >>> text == '<ns0:records xmlns:ns0="http://osafoundation.org/eim"><ns0:recordset deleted="true" uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" /></ns0:records>'
    True



Persisting RecordSets
---------------------


RecordSets can be stored and retrieved by UUID::

    >>> uuidString = '8501de14-1dc9-40d4-a7d4-f289feff8214'
    >>> recordSet = recordSets[uuidString]
    >>> share = sharing.Share(itsView=rv)
    >>> conduit = recordset_conduit.RecordSetConduit(itsView=rv)
    >>> share.conduit = conduit
    >>> conduit.saveStates(uuidString, recordSet, sharing.RecordSet())
    >>> agreed, pending = conduit.getStates(uuidString)
    >>> recordSet == agreed
    True




Inmemory Cosmo Replacement
--------------------------

You can "send" a recordset::

    >>> conduit = recordset_conduit.InMemoryRecordSetConduit(itsView=rv,
    ...     shareName="test1", serializer=eimml.EIMMLSerializerLite)
    >>> conduit.put(sampleLite)
    >>> conduit.syncToken
    '1'

If you don't use the previous token, you'll get a failure::

    >>> conduit.syncToken = '42'
    >>> conduit.put(sampleLite)
    Traceback (most recent call last):
    ...
    TokenMismatch: 42 != 1

The token changes whenever you modify the collection::

    >>> conduit.syncToken = '1'
    >>> conduit.put(sampleLite)
    >>> conduit.syncToken
    '2'

Send a new item::

    >>> text = '''<?xml version="1.0" encoding="UTF-8"?>
    ...
    ... <eim:records
    ... xmlns:eim="http://osafoundation.org/eim"
    ... xmlns:item="http://osafoundation.org/eim/item"
    ... xmlns:event="http://osafoundation.org/eim/event"
    ... xmlns:note="http://osafoundation.org/eim/note">
    ... <eim:recordset uuid="9501de14-1dc9-40d4-a7d4-f289feff8214">
    ...    <item:record uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" title="Welcome to Cosmo" triageStatus="now" triageStatusChanged="123456789.12" createdOn ="1164803131" />
    ...    <note:record uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" body="This is the body" icaluid="1e2d48c0-d66b-494c-bb33-c3d75a1ba66b" reminderTime="1169163900" />
    ...    <event:record uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" dtstart="20061130T140000" dtend="20061130T150000" rrule="FREQ=WEEKLY" status="CONFIRMED" />
    ... </eim:recordset>
    ... </eim:records>'''

    >>> conduit.put(text)
    >>> conduit.syncToken
    '3'

Doing a "get" with the most recent token returns no changes::

    >>> text = conduit.get()
    >>> conduit.syncToken
    '3'
    >>> text
    '<ns0:records xmlns:ns0="http://osafoundation.org/eim" />'

You can ask for recordsets that have been updated since a previous token was
created::

    >>> conduit.syncToken = '1'
    >>> text = conduit.get()
    >>> conduit.syncToken
    '3'
    >>> expectedRecordSets = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'now', decimal.Decimal("123456789.12"), u'foo@example.com', decimal.Decimal("1164803131")), sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', decimal.Decimal('1169163900')), sharing.model.EventRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'20061130T140000', u'20061130T150000', None, u'San Jose', u'FREQ=WEEKLY', None, None, None, u'CONFIRMED')]), '9501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.ItemRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'now', decimal.Decimal("123456789.12"), None, decimal.Decimal("1164803131")), sharing.model.NoteRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', decimal.Decimal('1169163900')), sharing.model.EventRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', u'20061130T140000', u'20061130T150000', None, None, u'FREQ=WEEKLY', None, None, None, u'CONFIRMED')]) }
    >>> recordSets = eimml.EIMMLSerializerLite.deserialize(text)
    >>> recordSets == expectedRecordSets
    True





Merging RecordSets
------------------

The RecordSetConduit class has a merge method which will compare inbound
and outbound changes, merge the non-overlapping changes, and return the
set of records to send outbound, the set of records to apply locally, and
the inbound changes that are pending due to conflict::

    >>> empty = rs()

    >>> barFilter = sharing.Filter('cid:bar-filter@osaf.us', u"Bars")
    >>> bazFilter = sharing.Filter('cid:baz-filter@osaf.us', u"Bazzes")

    >>> class Demo(sharing.Record):
    ...     URI = 'cid:eim.test.demo-record@osaf.us'
    ...     foo = sharing.key(int)
    ...     bar = sharing.field(int, [barFilter])
    ...     baz = sharing.field(int, [bazFilter])


Set up a conduit::

    >>> conduit = recordset_conduit.RecordSetConduit(itsView=rv)
    >>> conduit.filters = []

Verify the old state is empty::

    >>> conduit.getStates('1') == (empty, empty)
    True

Test a no-op (no inbound nor outbound changes)::

    >>> conduit.saveStates('1', empty, empty)
    >>> conduit.merge({ }, { }) == ({ }, { }, { })
    True
    >>> conduit.getStates('1') == (empty, empty)
    True

Merge a local addition with no inbound changes::

    >>> rsNewBase =   { '1' : rs([Demo(1, 1, 1)]) }
    >>> inboundDiff = { }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1': rs(set([Demo(1, 1, 1)]))}
    True
    >>> toApply == { }
    True
    >>> pending == { }
    True

    >>> conduit.saveStates('1', empty, empty)
    >>> conduit.merge(
    ...     { '1' : rs([Demo(1, 1, 1)]) }, { }
    ... ) == (
    ...     {'1': rs(set([Demo(1, 1, 1)]))}, { }, { }
    ... )
    True

Verify the old baseline has been updated::
    >>> conduit.getStates('1') == (rs(set([Demo(1,1,1)])), empty)
    True

Merge in an inbound change (no outbound changes)::

    >>> conduit.merge(
    ...     { }, { '1' : rs([Demo(1, 1, 2)]) }
    ... ) == (
    ...     { }, {'1': rs(set([Demo(1, nc, 2)]))}, { }
    ... )
    True

    >>> conduit.getStates('1') == (rs(set([Demo(1,1,2)])), empty)
    True

Merge non-overlapping inbound and outbound changes::

    >>> rsNewBase =   { '1' : rs([Demo(1, 3, 2)]) }
    >>> inboundDiff = { '1' : rs([Demo(1, 1, 3)]) }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1': rs(set([Demo(1, 3, nc)]))}
    True
    >>> toApply == {'1': rs(set([Demo(1, nc, 3)]))}
    True
    >>> pending == { }
    True
    >>> conduit.getStates('1') == (rs(set([Demo(1,3,3)])), empty)
    True

Merge overlapping and non-overlapping inbound and outbound changes, resulting
in pending inbound changes::

    >>> rsNewBase =   { '1' : rs([Demo(1, 4, 4)]) }
    >>> inboundDiff = { '1' : rs([Demo(1, 5, nc)]) }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1': rs(set([Demo(1, nc, 4)]))}
    True
    >>> toApply == { }
    True
    >>> pending == {'1': rs(set([Demo(1, 5, nc)]))}
    True
    >>> conduit.getStates('1') == (rs(set([Demo(1,3,4)])), rs(set([Demo(1,5,nc)])))
    True

With pending changes, non-conflicting local modifications can still go out::

    >>> rsNewBase =   { '1' : rs([Demo(1, 4, 5)]) }
    >>> inboundDiff = { }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1': rs(set([Demo(1, nc, 5)]))}
    True
    >>> toApply == { }
    True
    >>> pending == {'1': rs(set([Demo(1, 5, nc)]))}
    True
    >>> conduit.getStates('1') == (rs(set([Demo(1,3,5)])), rs(set([Demo(1,5,nc)])))
    True

See that a pending change can disappear due to a later inbound change:

    >>> rsNewBase =   { } # Note: without specifying the full recordset for this item, a redundant toApply appears
    >>> rsNewBase =   { '1' : rs([Demo(1, 4, 5)]) }
    >>> inboundDiff = { '1' : rs([Demo(1, 4, 5)]) }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == { }
    True
    >>> pending == { }
    True
    >>> conduit.getStates('1') == (rs(set([Demo(1,4,5)])), empty)
    True

Merge only overlapping inbound and outbound changes::

    >>> rsNewBase =   { '1' : rs([Demo(1, 4, 6)]) }
    >>> inboundDiff = { '1' : rs([Demo(1, 4, 7)]) }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == { }
    True
    >>> pending == {'1': rs(set([Demo(1, nc, 7)]))}
    True
    >>> conduit.getStates('1') == (rs(set([Demo(1,4,5)])), rs(set([Demo(1,nc,7)])))
    True

Add in a filter, make a local change and no inbound changes::

    >>> conduit.filters = ['cid:bar-filter@osaf.us']
    >>> rsNewBase = { '1' : rs([Demo(1, 6, 8)]) }
    >>> inboundDiff = { }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == { }
    True
    >>> pending == {'1': rs(set([Demo(1, nc, 7)]))}
    True
    >>> conduit.getStates('1') == (rs(set([Demo(1,4,5)])), rs(set([Demo(1,nc,7)])))
    True

Even though we locally modified the 'bar' field, it is not sent because of
the filter.  Even though we locally modified the 'baz' field, since there is
an outstanding pending change it is also not sent.

See that a pending change can disappear due to a later outbound change:

    >>> rsNewBase =   { '1' : rs([Demo(1, 6, 7)]) }
    >>> inboundDiff = { }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == { }
    True
    >>> pending == { }
    True
    >>> conduit.getStates('1') == (rs(set([Demo(1,4,7)])), empty)
    True

There can be multiple filters in effect; note how we locally change both fields
yet send nothing, and the agreed upon state doesn't change::

    >>> conduit.filters = ['cid:bar-filter@osaf.us', 'cid:baz-filter@osaf.us']
    >>> rsNewBase = { '1' : rs([Demo(1, 7, 8)]) }
    >>> inboundDiff = { }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == { }
    True
    >>> pending == { }
    True
    >>> conduit.getStates('1') == (rs(set([Demo(1,4,7)])), empty)
    True

Verify that inbound changes to filtered fields are not applied locally, yet
unfiltered inbound changes are applied::

    >>> conduit.filters = ['cid:bar-filter@osaf.us']
    >>> rsNewBase = { }
    >>> inboundDiff = { '1' : rs([Demo(1, 5, 8)]) }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == {'1': rs(set([Demo(1, nc, 8)]))}
    True
    >>> pending == { }
    True
    >>> conduit.getStates('1') == (rs(set([Demo(1,4,8)])), empty)
    True

Verify that inbound and outbound changes to a filtered field is not considered
a conflict::

    >>> rsNewBase =   { '1' : rs([Demo(1, 8, 9)]) }
    >>> inboundDiff = { '1' : rs([Demo(1, 9, 9)]) }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == { }
    True
    >>> pending == { }
    True
    >>> conduit.getStates('1') == (rs(set([Demo(1,4,9)])), empty)
    True

Verify that conflicts can still be detected when at least one conflicting
field is not filtered::

    >>> rsNewBase =   { '1' : rs([Demo(1, 9, 10)]) }
    >>> inboundDiff = { '1' : rs([Demo(1, 10, 11)]) }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == { }
    True
    >>> pending == {'1': rs(set([Demo(1, nc, 11)]))}
    True
    >>> conduit.getStates('1') == (rs(set([Demo(1,4,9)])), rs(set([Demo(1, nc, 11)])))
    True


Start over, to test that local deletions get sent::

    >>> conduit.filters = []
    >>> conduit.saveStates('1', rs(set([Demo(1,1,1)])), rs())

    >>> rsNewBase = { '1' : rs() }
    >>> inboundDiff =   { }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1': rs([], set([Demo(1, 1, 1)]))}
    True
    >>> toApply == { }
    True
    >>> pending == { }
    True


Start over, to test that remote deletions get applied::

    >>> conduit.saveStates('1', rs(set([Demo(1,1,1)])), rs())

    >>> rsNewBase =   { }
    >>> inboundDiff = { '1' : rs([], [Demo(1, nc, nc)]) }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == {'1': rs([], set([Demo(1, 1, 1)]))}
    True
    >>> pending == { }
    True


Start over, to test that local changes and remote deletions get detected::

    >>> conduit.saveStates('1', rs(set([Demo(1,1,1)])), rs())

    >>> rsNewBase = { '1' : rs([Demo(1, 2, 2)]) }
    >>> inboundDiff = { '1' : rs([], [Demo(1, nc, nc)]) }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == { }
    True
    >>> pending == {'1': rs([], set([Demo(1, 1, 1)]))}
    True
    >>> conduit.getStates('1') == (rs(set([Demo(1,1,1)])), rs([], set([Demo(1, 1, 1)])))
    True


Start over, to test that local deletions and remote changes get detected::


    >>> conduit.saveStates('1', rs(set([Demo(1,1,1)])), rs())

    >>> rsNewBase = { '1' : rs() }
    >>> inboundDiff = { '1' : rs([Demo(1, 2, 2)]) }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == { }
    True
    >>> pending == {'1': rs(set([Demo(1, 2, 2)]))}
    True
    >>> conduit.getStates('1') == (rs(set([Demo(1,1,1)])), rs(set([Demo(1, 2, 2)])))
    True






Start over, adding two records (one of a new record type)::

    >>> class Demo2(sharing.Record):
    ...     URI = 'cid:eim.test.demo2-record@osaf.us'
    ...     foo = sharing.key(int)
    ...     bar = sharing.field(int, [barFilter])
    ...     baz = sharing.field(int, [bazFilter])

    >>> conduit.filters = []
    >>> conduit.saveStates('1', rs(set([Demo(1,1,1), Demo2(1, 2, 2)])), rs())

...now remove the Demo(1,1,1), and the result of the merge will be that we
will send a deletion for that record::

    >>> rsNewBase =   { '1' : rs(set([Demo2(1,2,2)])) }
    >>> inboundDiff = { }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1' : rs(set([]), set([Demo(1,1,1)])) }
    True
    >>> conduit.getStates('1') == (rs(set([Demo2(1,2,2)])), empty)
    True

If a record is removed inbound and outbound, that is not a conflict.  Note
that a double-deletion results in an unnecessary record deletion in toApply,
but record adding and deleting need to be idempotent anyway, so it's ok::

    >>> rsNewBase =   { '1' : empty }
    >>> inboundDiff =   { '1' : empty }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1' : rs(set([]), set([Demo2(1,2,2)]))} # will be a no-op
    True
    >>> toApply == { }
    True
    >>> pending == { }
    True
    >>> conduit.getStates('1') == (empty, empty)
    True



Start over, with a filter this time from the start::

    >>> conduit.filters = ['cid:bar-filter@osaf.us']
    >>> conduit.saveStates('1', empty, empty)

Merge a local addition with no inbound changes; note that the outbound
record has a NoChange value on the filtered field::

    >>> rsNewBase = { '1' : rs([Demo(1, 1, 1)]) }
    >>> inboundDiff = { }
    >>> toSend, toApply, pending = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1': rs(set([Demo(1, nc, 1)]))}
    True

