
Serializing Values
------------------


First define a record type::

    >>> from application import schema
    >>> from osaf import sharing, pim
    >>> from osaf.sharing import ( eimml, recordset_conduit, State, getFilter,
    ...                            RecordSet as rs, NoChange as nc )
    >>> from PyICU import ICUtzinfo
    >>> import datetime, decimal
    >>> from repository.persistence.RepositoryView import NullRepositoryView
    >>> rv = NullRepositoryView()
    >>> class TestRecord(sharing.Record):
    ...     URI = 'cid:TestRecord@osaf.us'
    ...     textField = sharing.field(sharing.TextType(size=100))
    ...     decimalField = sharing.field(sharing.DecimalType(digits=11,
    ...                                  decimal_places=2))
    ...     dateField = sharing.field(sharing.DateType)


Translate text values::

    >>> value = eimml.deserializeValue(TestRecord.textField.typeinfo, 'xyzzy')
    >>> value
    'xyzzy'
    >>> eimml.serializeValue(TestRecord.textField.typeinfo, value)
    ('xyzzy', 'text')


Translate decimal values::

    >>> value = eimml.deserializeValue(TestRecord.decimalField.typeinfo, '123.45')
    >>> value
    Decimal("123.45")
    >>> eimml.serializeValue(TestRecord.decimalField.typeinfo, value)
    ('123.45', 'decimal')


Translate datetime values::

    >>> value = eimml.deserializeValue(TestRecord.dateField.typeinfo,
    ... '2007-01-30T15:45:30.098593-08:00')
    >>> value
    datetime.datetime(2007, 1, 30, 15, 45, 30, 98593, tzinfo=<ICUtzinfo: Etc/GMT+8>)
    >>> eimml.serializeValue(TestRecord.dateField.typeinfo, value)
    ('2007-01-30T15:45:30.098593-08:00', 'datetime')

TODO: int, lob, bytes


Serialize and deserialize entire record sets using EIMMLSerializerLite::

    >>> sampleLite = '''<?xml version="1.0" encoding="UTF-8"?>
    ...
    ... <eim:collection a="1" b="2"
    ... xmlns:eim="http://osafoundation.org/eim"
    ... xmlns:item="http://osafoundation.org/eim/item"
    ... xmlns:event="http://osafoundation.org/eim/event"
    ... xmlns:note="http://osafoundation.org/eim/note">
    ... <eim:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214">
    ...    <item:record uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" title="Welcome to Cosmo" triageStatus="now" triageStatusChanged="123456789.12" lastModifiedBy="foo@example.com" createdOn="1164803131" />
    ...    <note:record uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" body="This is the body" icaluid="1e2d48c0-d66b-494c-bb33-c3d75a1ba66b" reminderTime="1169163900" />
    ...    <event:record uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" dtstart=":20061130T140000" dtend=":20061130T150000" location="San Jose" rrule="FREQ=WEEKLY" status="CONFIRMED" />
    ... </eim:recordset>
    ... </eim:collection>'''

    >>> expectedRecordSets = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'now', decimal.Decimal("123456789.12"), u'foo@example.com', decimal.Decimal("1164803131")), sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', decimal.Decimal('1169163900')), sharing.model.EventRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u':20061130T140000', u':20061130T150000', u'San Jose', u'FREQ=WEEKLY', None, None, None, u'CONFIRMED')])}

    >>> recordSets, extra = eimml.EIMMLSerializerLite.deserialize(sampleLite)
    >>> recordSets == expectedRecordSets
    True
    >>> extra
    {'a': '1', 'b': '2'}

    >>> text = eimml.EIMMLSerializerLite.serialize(recordSets, name="foo")

    >>> recordSets, extra = eimml.EIMMLSerializerLite.deserialize(text)
    >>> recordSets == expectedRecordSets
    True

    >>> extra
    {'name': 'foo'}


Serialize and deserialize entire record sets using EIMMLSerializer::


    >>> sample = '''<?xml version='1.0' encoding='UTF-8'?>
    ...
    ... <eim:collection name="foo" xmlns:eim="http://osafoundation.org/eim">
    ...   <eim:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214">
    ...     <item:record xmlns:item="http://osafoundation.org/eim/item">
    ...       <item:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></item:uuid>
    ...       <item:title eim:type="text"><![CDATA[Welcome to Cosmo]]></item:title>
    ...       <item:triageStatus eim:type="text"><![CDATA[now]]></item:triageStatus>
    ...       <item:triageStatusChanged eim:type="decimal"><![CDATA[123456789.12]]></item:triageStatusChanged>
    ...       <item:lastModifiedBy eim:type="text"><![CDATA[foo@example.com]]></item:lastModifiedBy>
    ...       <item:createdOn eim:type="decimal"><![CDATA[1164803131]]></item:createdOn>
    ...     </item:record>
    ...     <note:record xmlns:note="http://osafoundation.org/eim/note">
    ...       <note:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></note:uuid>
    ...       <note:body eim:type="clob"><![CDATA[This is the body]]></note:body>
    ...       <note:icaluid eim:type="text"><![CDATA[1e2d48c0-d66b-494c-bb33-c3d75a1ba66b]]></note:icaluid>
    ...       <note:reminderTime eim:type="decimal"><![CDATA[1169163900]]></note:reminderTime>
    ...     </note:record>
    ...     <event:record xmlns:event="http://osafoundation.org/eim/event">
    ...       <event:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></event:uuid>
    ...       <event:dtstart eim:type="text"><![CDATA[:20061130T140000]]></event:dtstart>
    ...       <event:dtend eim:type="text"><![CDATA[:20061130T150000]]></event:dtend>
    ...       <event:location eim:type="text"><![CDATA[San Jose]]></event:location>
    ...       <event:rrule eim:type="text"><![CDATA[FREQ=WEEKLY]]></event:rrule>
    ...       <event:exrule eim:type="text" />
    ...       <event:rdate eim:type="text" />
    ...       <event:exdate eim:type="text" />
    ...       <event:status eim:type="text"><![CDATA[CONFIRMED]]></event:status>
    ...     </event:record>
    ...   </eim:recordset>
    ... </eim:collection>'''

    >>> recordSets, extra = eimml.EIMMLSerializer.deserialize(sample)
    >>> recordSets == expectedRecordSets
    True

    >>> extra
    {'name': 'foo'}

    >>> text = eimml.EIMMLSerializer.serialize(recordSets, name="foo")

    >>> recordSets, extra = eimml.EIMMLSerializer.deserialize(text)
    >>> recordSets == expectedRecordSets
    True

    >>> extra
    {'name': 'foo'}


Any records in a recordset's exclusions are serialized as deletions::

    >>> recordDeletion = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs(set([]), set([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'now', decimal.Decimal("123456789.12"), u'foo@example.com', decimal.Decimal("1164803131"))]))}
    >>> text = eimml.EIMMLSerializer.serialize(recordDeletion)
    >>> text
    '<ns0:collection xmlns:ns0="http://osafoundation.org/eim"><ns0:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214"><ns1:record deleted="true" xmlns:ns1="http://osafoundation.org/eim/item"><ns1:uuid key="true" type="text">8501de14-1dc9-40d4-a7d4-f289feff8214</ns1:uuid></ns1:record></ns0:recordset></ns0:collection>'

To indicate that item has been deleted, pass None instead of a recordset::

    >>> itemDeletion = { '8501de14-1dc9-40d4-a7d4-f289feff8214' : None }
    >>> text = eimml.EIMMLSerializer.serialize(itemDeletion)
    >>> text
    '<ns0:collection xmlns:ns0="http://osafoundation.org/eim"><ns0:recordset deleted="true" uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" /></ns0:collection>'





Inmemory Cosmo Replacement
--------------------------

You can "send" a recordset::

    >>> conduit = recordset_conduit.InMemoryRecordSetConduit(itsView=rv,
    ...     shareName="test1", serializer=eimml.EIMMLSerializerLite)
    >>> conduit.put(sampleLite)
    >>> conduit.syncToken
    '1'

If you don't use the previous token, you'll get a failure::

    >>> conduit.syncToken = '42'
    >>> conduit.put(sampleLite)
    Traceback (most recent call last):
    ...
    TokenMismatch: 42 != 1

The token changes whenever you modify the collection::

    >>> conduit.syncToken = '1'
    >>> conduit.put(sampleLite)
    >>> conduit.syncToken
    '2'

Send a new item::

    >>> text = '''<?xml version="1.0" encoding="UTF-8"?>
    ...
    ... <eim:records
    ... xmlns:eim="http://osafoundation.org/eim"
    ... xmlns:item="http://osafoundation.org/eim/item"
    ... xmlns:event="http://osafoundation.org/eim/event"
    ... xmlns:note="http://osafoundation.org/eim/note">
    ... <eim:recordset uuid="9501de14-1dc9-40d4-a7d4-f289feff8214">
    ...    <item:record uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" title="Welcome to Cosmo" triageStatus="now" triageStatusChanged="123456789.12" createdOn ="1164803131" />
    ...    <note:record uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" body="This is the body" icaluid="1e2d48c0-d66b-494c-bb33-c3d75a1ba66b" reminderTime="1169163900" />
    ...    <event:record uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" dtstart=":20061130T140000" dtend=":20061130T150000" rrule="FREQ=WEEKLY" status="CONFIRMED" />
    ... </eim:recordset>
    ... </eim:records>'''

    >>> conduit.put(text)
    >>> conduit.syncToken
    '3'

Doing a "get" with the most recent token returns no changes::

    >>> text = conduit.get()
    >>> conduit.syncToken
    '3'
    >>> text
    '<ns0:collection xmlns:ns0="http://osafoundation.org/eim" />'

You can ask for recordsets that have been updated since a previous token was
created::

    >>> conduit.syncToken = '1'
    >>> text = conduit.get()
    >>> conduit.syncToken
    '3'
    >>> expectedRecordSets = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'now', decimal.Decimal("123456789.12"), u'foo@example.com', decimal.Decimal("1164803131")), sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', decimal.Decimal('1169163900')), sharing.model.EventRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u':20061130T140000', u':20061130T150000', u'San Jose', u'FREQ=WEEKLY', None, None, None, u'CONFIRMED')]), '9501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.ItemRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'now', decimal.Decimal("123456789.12"), None, decimal.Decimal("1164803131")), sharing.model.NoteRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', decimal.Decimal('1169163900')), sharing.model.EventRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', u':20061130T140000', u':20061130T150000', None, u'FREQ=WEEKLY', None, None, None, u'CONFIRMED')]) }
    >>> recordSets, extra = eimml.EIMMLSerializerLite.deserialize(text)
    >>> recordSets == expectedRecordSets
    True





Merging RecordSets
------------------

The RecordSetConduit class has a merge method which will compare inbound
and outbound changes, merge the non-overlapping changes, and return the
set of records to send outbound, the set of records to apply locally, and
the inbound changes that are pending due to conflict::

    >>> empty = rs()

    >>> barFilter = sharing.Filter('cid:bar-filter@osaf.us', u"Bars")
    >>> bazFilter = sharing.Filter('cid:baz-filter@osaf.us', u"Bazzes")

    >>> import osaf.sharing
    >>> __name__ = "osaf.sharing"
    >>> class Demo(sharing.Record):
    ...     URI = 'cid:eim.test.demo-record@osaf.us'
    ...     foo = sharing.key(int)
    ...     bar = sharing.field(int, [barFilter])
    ...     baz = sharing.field(int, [bazFilter])
    >>> osaf.sharing.Demo = Demo

    >>> state = State(itsView=rv)

Verify the state is empty
    >>> state
    State(RecordSet(set([]), set([])), RecordSet(set([]), set([])))

Test a no-op (no inbound nor outbound changes)::

    >>> state.merge(empty, empty)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

Verify the state is still empty
    >>> state
    State(RecordSet(set([]), set([])), RecordSet(set([]), set([])))

Merge a local addition with no inbound changes::

    >>> state.merge(rs([Demo(1, 1, 1)]), empty)
    (RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

Verify the state has been updated::

    >>> state
    State(RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([]), set([])))


Merge in an inbound change (no outbound changes)::

    >>> state.merge(rs([Demo(1, 1, 1)]), rs(set([Demo(1, 1, 2)])))
    (RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 2)]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 1, 2)]), set([])), RecordSet(set([]), set([])))


Merge non-overlapping inbound and outbound changes::

    >>> state.merge(rs([Demo(1, 3, 2)]), rs([Demo(1, 1, 3)]))
    (RecordSet(set([Demo(1, 3, NoChange)]), set([])), RecordSet(set([Demo(1, NoChange, 3)]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 3, 3)]), set([])), RecordSet(set([]), set([])))


Merge overlapping and non-overlapping inbound and outbound changes, resulting
in pending inbound changes::

    >>> state.merge(rs([Demo(1, 4, 4)]), rs([Demo(1, 5, nc)]))
    (RecordSet(set([Demo(1, NoChange, 4)]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 3, 4)]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))


With pending changes, non-conflicting local modifications can still go out::

    >>> state.merge(rs([Demo(1, 4, 5)]))
    (RecordSet(set([Demo(1, NoChange, 5)]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 3, 5)]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))


See that a pending change can disappear due to a later inbound change:

    >>> state.merge(rs([Demo(1, 4, 5)]), rs([Demo(1, 4, 5)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 5)]), set([])), RecordSet(set([]), set([])))


Merge only overlapping inbound and outbound changes::

    >>> state.merge(rs([Demo(1, 4, 6)]), rs([Demo(1, 4, 7)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 7)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 5)]), set([])), RecordSet(set([Demo(1, NoChange, 7)]), set([])))


Add in a filter, make a local change and no inbound changes::

    >>> filter = getFilter(['cid:bar-filter@osaf.us'])
    >>> state.merge(rs([Demo(1, 6, 8)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 7)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 5)]), set([])), RecordSet(set([Demo(1, NoChange, 7)]), set([])))


Even though we locally modified the 'bar' field, it is not sent because of
the filter.  Even though we locally modified the 'baz' field, since there is
an outstanding pending change it is also not sent.

See that a pending change can disappear due to a later outbound change:

    >>> state.merge(rs([Demo(1, 6, 7)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 7)]), set([])), RecordSet(set([]), set([])))


There can be multiple filters in effect; note how we locally change both fields
yet send nothing, and the agreed upon state doesn't change::

    >>> filter = getFilter(['cid:bar-filter@osaf.us', 'cid:baz-filter@osaf.us'])
    >>> state.merge(rs([Demo(1, 7, 8)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 7)]), set([])), RecordSet(set([]), set([])))


Verify that inbound changes to filtered fields are not applied locally, yet
unfiltered inbound changes are applied::

    >>> filter = getFilter(['cid:bar-filter@osaf.us'])
    >>> state.merge(rs([Demo(1, 7, 8)]), rs([Demo(1, 5, 8)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 8)]), set([])), RecordSet(set([]), set([])))


Verify that inbound and outbound changes to a filtered field is not considered
a conflict::

    >>> state.merge(rs([Demo(1, 8, 9)]), rs([Demo(1, 9, 9)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 9)]), set([])), RecordSet(set([]), set([])))


Verify that conflicts can still be detected when at least one conflicting
field is not filtered::

    >>> state.merge(rs([Demo(1, 9, 10)]), rs([Demo(1, 10, 11)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 11)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 9)]), set([])), RecordSet(set([Demo(1, NoChange, 11)]), set([])))



Start over, to test that local deletions get sent::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)

    >>> state.merge(empty)
    (RecordSet(set([]), set([Demo(1, 1, 1)])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))



Start over, to test that remote deletions get applied::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)
    >>> state.merge(rs([Demo(1, 1, 1)]), rs([], [Demo(1, nc, nc)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([Demo(1, 1, 1)])), RecordSet(set([]), set([])))



Start over, to test that local changes and remote deletions get detected::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)
    >>> state.merge(rs([Demo(1, 2, 2)]), rs([], [Demo(1, nc, nc)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([Demo(1, 1, 1)])))

    >>> state
    State(RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([]), set([Demo(1, 1, 1)])))


Start over, to test that local deletions and remote changes get detected::


    >>> state.set(rs(set([Demo(1,1,1)])), empty)
    >>> state.merge(empty, rs([Demo(1, 2, 2)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 2, 2)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([Demo(1, 2, 2)]), set([])))







Start over, adding two records (one of a new record type)::

    >>> class Demo2(sharing.Record):
    ...     URI = 'cid:eim.test.demo2-record@osaf.us'
    ...     foo = sharing.key(int)
    ...     bar = sharing.field(int, [barFilter])
    ...     baz = sharing.field(int, [bazFilter])
    >>> osaf.sharing.Demo2 = Demo2

    >>> state.set(rs(set([Demo(1,1,1), Demo2(1,2,2)])), empty)

...now remove the Demo(1,1,1), and the result of the merge will be that we
will send a deletion for that record::

    >>> state.merge(rs([Demo2(1, 2, 2)]))
    (RecordSet(set([]), set([Demo(1, 1, 1)])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo2(1, 2, 2)]), set([])), RecordSet(set([]), set([])))


If a record is removed inbound and outbound, that is not a conflict.  Note
that a double-deletion results in an unnecessary record deletion in toApply,
but record adding and deleting need to be idempotent anyway, so it's ok::

    >>> state.merge(empty, empty)
    (RecordSet(set([]), set([Demo2(1, 2, 2)])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([]), set([])), RecordSet(set([]), set([])))




Start over, with a filter this time from the start::

    >>> filter = getFilter(['cid:bar-filter@osaf.us'])
    >>> state.set(empty, empty)

Merge a local addition with no inbound changes; note that the outbound
record has a NoChange value on the filtered field::

    >>> state.merge(rs([Demo(1, 1, 1)]), filter=filter)
    (RecordSet(set([Demo(1, NoChange, 1)]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))






Itemcentric Sharing
-------------------

Items can be shared with a peer without using a persistent Share/Conduit.
The sharing package provides methods for translating items to EIMML and
back.

    >>> rv0 = NullRepositoryView()
    >>> rv1 = NullRepositoryView()
    >>> item0 = pim.Note(itsView=rv0, displayName="test displayName",
    ...     body="test body", triageStatus=pim.TriageEnum.later)
    >>> uuid = item0.itsUUID.str16()
    >>> not pim.has_stamp(item0, sharing.SharedItem)
    True

    >>> pje = schema.Item(itsView=rv0)
    >>> morgen = schema.Item(itsView=rv1)

An item is serialized to EIMML using the outbound method.  The first argument
is an item which identifies the peer we're sharing with; the sharing package
doesn't care what this item is; it could be a Contact item, or email address
item, etc., as long as it's a persistent Chandler item.

    >>> text = sharing.outbound(pje, item0)

Sharing an item this way automatically stamps the item as SharedItem.

    >>> pim.has_stamp(item0, sharing.SharedItem)
    True

An item is imported via the inbound method.

    >>> item1 = sharing.inbound(morgen, text)
    >>> item1 is not None
    True
    >>> pim.has_stamp(item1, sharing.SharedItem)
    True

    >>> item1.displayName
    u'test displayName'

    >>> item1.body
    u'test body'

    >>> item1.triageStatus
    TriageEnum.later

Send changes back

    >>> item1.triageStatus = pim.TriageEnum.now
    >>> text = sharing.outbound(morgen, item1)
    >>> item0 = sharing.inbound(pje, text)
    >>> item0.triageStatus
    TriageEnum.now

Conflicts are accessed via statesWithConflicts (until a better API)

    >>> shared0 = sharing.SharedItem(item0)
    >>> not hasattr(shared0, 'statesWithConflicts')
    True

    >>> shared1 = sharing.SharedItem(item1)
    >>> not hasattr(shared1, 'statesWithConflicts')
    True

Cause a conflict:

    >>> item0.displayName = "changed by morgen"
    >>> item1.displayName = "changed by pje"
    >>> text = sharing.outbound(pje, item0)
    >>> item1 = sharing.inbound(morgen, text)
    >>> shared1.getConflicts()
    [(<Item (new): ...>, RecordSet(set([ItemRecord(u'...', u'changed by morgen', NoChange, ..., NoChange, NoChange)]), set([])))]
