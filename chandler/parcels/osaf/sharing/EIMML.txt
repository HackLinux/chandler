
Serializing Values
------------------


First define a record type::

    >>> from osaf import sharing
    >>> from osaf.sharing import eimml, recordset_conduit
    >>> from PyICU import ICUtzinfo
    >>> import datetime, decimal
    >>> from repository.persistence.RepositoryView import NullRepositoryView
    >>> rv = NullRepositoryView()
    >>> class TestRecord(sharing.Record):
    ...     URI = 'cid:TestRecord@osaf.us'
    ...     textField = sharing.field(sharing.TextType(size=100))
    ...     decimalField = sharing.field(sharing.DecimalType(digits=11,
    ...                                  decimal_places=2))
    ...     dateField = sharing.field(sharing.DateType)


Translate text values::

    >>> value = eimml.deserializeValue(TestRecord.textField.typeinfo, 'xyzzy')
    >>> value
    'xyzzy'
    >>> eimml.serializeValue(TestRecord.textField.typeinfo, value)
    'xyzzy'


Translate decimal values::

    >>> value = eimml.deserializeValue(TestRecord.decimalField.typeinfo, '123.45')
    >>> value
    Decimal("123.45")
    >>> eimml.serializeValue(TestRecord.decimalField.typeinfo, value)
    '123.45'


Translate datetime values::

    >>> value = eimml.deserializeValue(TestRecord.decimalField.typeinfo, '123.45')
    >>> value
    Decimal("123.45")
    >>> eimml.serializeValue(TestRecord.decimalField.typeinfo, value)
    '123.45'


TODO: int, lob, bytes


Serialize and deserialize entire record sets::

    >>> sample = '''<?xml version="1.0" encoding="UTF-8"?>
    ...
    ... <eim:records
    ... xmlns:eim="http://osafoundation.org/eimml/core"
    ... xmlns:item="http://osafoundation.org/eimml/item"
    ... xmlns:event="http://osafoundation.org/eimml/event"
    ... xmlns:note="http://osafoundation.org/eimml/note">
    ... <eim:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214">
    ...    <item:record uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" title="Welcome to Cosmo" triage_status="now" triage_status_changed="123456789.12" created_on ="2006-11-29 12:25:31 US/Pacific" />
    ...    <note:record uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" body="VGhpcyBpcyB0aGUgYm9keQ==" icaluid="1e2d48c0-d66b-494c-bb33-c3d75a1ba66b" />
    ...    <event:record uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" dtstart="20061130T140000" dtend="20061130T150000" rrule="FREQ=WEEKLY" status="CONFIRMED" />
    ... </eim:recordset>
    ... </eim:records>'''

    >>> expectedRecordSets = { '8501de14-1dc9-40d4-a7d4-f289feff8214': sharing.RecordSet([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'now', decimal.Decimal("123456789.12"), None, datetime.datetime(2006, 11, 29, 12, 25, 31, tzinfo=ICUtzinfo.getInstance('US/Pacific')), None), sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b'), sharing.model.EventRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'20061130T140000', u'20061130T150000', None, u'FREQ=WEEKLY', None, None, None, None, u'CONFIRMED', None)])}

    >>> recordSets = eimml.EIMMLSerializer.deserialize(sample)
    >>> recordSets == expectedRecordSets
    True

    >>> text = eimml.EIMMLSerializer.serialize(recordSets)

    >>> recordSets = eimml.EIMMLSerializer.deserialize(text)
    >>> recordSets == expectedRecordSets
    True



Persisting RecordSets
---------------------


RecordSets can be stored and retrieved by UUID::

    >>> uuidString = '8501de14-1dc9-40d4-a7d4-f289feff8214'
    >>> recordSet = recordSets[uuidString]
    >>> share = sharing.Share(itsView=rv)
    >>> conduit = recordset_conduit.RecordSetConduit(itsView=rv)
    >>> share.conduit = conduit
    >>> conduit.saveRecordSet(uuidString, recordSet)
    >>> newRecordSet = conduit.getRecordSet(uuidString)
    >>> recordSet == newRecordSet
    True



Inmemory Cosmo Replacement
--------------------------

You can "send" a recordset::

    >>> conduit = recordset_conduit.InMemoryRecordSetConduit(itsView=rv,
    ...     shareName="test1", serializer=eimml.EIMMLSerializer)
    >>> conduit.put(text)
    >>> conduit.syncToken
    1

If you don't use the previous token, you'll get a failure::

    >>> conduit.syncToken = 42
    >>> conduit.put(text)
    Traceback (most recent call last):
    ...
    TokenMismatch: 42 != 1

The token changes whenever you modify the collection::

    >>> conduit.syncToken = 1
    >>> conduit.put(text)
    >>> conduit.syncToken
    2

Send a new item::

    >>> text = '''<?xml version="1.0" encoding="UTF-8"?>
    ...
    ... <eim:records
    ... xmlns:eim="http://osafoundation.org/eimml/core"
    ... xmlns:item="http://osafoundation.org/eimml/item"
    ... xmlns:event="http://osafoundation.org/eimml/event"
    ... xmlns:note="http://osafoundation.org/eimml/note">
    ... <eim:recordset uuid="9501de14-1dc9-40d4-a7d4-f289feff8214">
    ...    <item:record uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" title="Welcome to Cosmo" triage_status="now" triage_status_changed="123456789.12" created_on ="2006-11-29 12:25:31 US/Pacific" />
    ...    <note:record uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" body="VGhpcyBpcyB0aGUgYm9keQ==" icaluid="1e2d48c0-d66b-494c-bb33-c3d75a1ba66b" />
    ...    <event:record uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" dtstart="20061130T140000" dtend="20061130T150000" rrule="FREQ=WEEKLY" status="CONFIRMED" />
    ... </eim:recordset>
    ... </eim:records>'''

    >>> conduit.put(text)
    >>> conduit.syncToken
    3

Doing a "get" with the most recent token returns no changes::

    >>> text = conduit.get()
    >>> conduit.syncToken
    3
    >>> text
    '<ns0:records xmlns:ns0="http://osafoundation.org/eimml/core" />'

You can ask for recordsets that have been updated since a previous token was
created::

    >>> conduit.syncToken = 1
    >>> text = conduit.get()
    >>> conduit.syncToken
    3
    >>> expectedRecordSets = { '8501de14-1dc9-40d4-a7d4-f289feff8214': sharing.RecordSet([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'now', decimal.Decimal("123456789.12"), None, datetime.datetime(2006, 11, 29, 12, 25, 31, tzinfo=ICUtzinfo.getInstance('US/Pacific')), None), sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b'), sharing.model.EventRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'20061130T140000', u'20061130T150000', None, u'FREQ=WEEKLY', None, None, None, None, u'CONFIRMED', None)]), '9501de14-1dc9-40d4-a7d4-f289feff8214': sharing.RecordSet([sharing.model.ItemRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'now', decimal.Decimal("123456789.12"), None, datetime.datetime(2006, 11, 29, 12, 25, 31, tzinfo=ICUtzinfo.getInstance('US/Pacific')), None), sharing.model.NoteRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b'), sharing.model.EventRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', u'20061130T140000', u'20061130T150000', None, u'FREQ=WEEKLY', None, None, None, None, u'CONFIRMED', None)]) }
    >>> recordSets = eimml.EIMMLSerializer.deserialize(text)
    >>> recordSets == expectedRecordSets
    True





Merging RecordSets
------------------

The RecordSetConduit class has a merge method which will compare inbound
and outbound changes, merge the non-overlapping changes, and return the
set of records to send outbound, the set of records to apply locally, and
the local changes that were lost due to conflict::

    >>> from osaf.sharing import RecordSet as rs, NoChange as nc

    >>> barFilter = sharing.Filter('cid:bar-filter@osaf.us', u"Bars")
    >>> bazFilter = sharing.Filter('cid:baz-filter@osaf.us', u"Bazzes")

    >>> class Demo(sharing.Record):
    ...     URI = 'cid:eim.test.demo-record@osaf.us'
    ...     foo = sharing.key(int)
    ...     bar = sharing.field(int, [barFilter])
    ...     baz = sharing.field(int, [bazFilter])

Set up a conduit::

    >>> conduit = recordset_conduit.RecordSetConduit(itsView=rv)
    >>> conduit.filters = []

Verify the old baseline is empty::

    >>> conduit.getRecordSet('1') == rs()
    True

Test a no-op (no inbound nor outbound changes)::

    >>> rsNewBase = { }
    >>> inboundDiff = { }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == { }
    True
    >>> lost == { }
    True
    >>> conduit.getRecordSet('1') == rs()
    True

Merge a local addition with no inbound changes::

    >>> rsNewBase =   { '1' : rs([Demo(1, 1, 1)]) }
    >>> inboundDiff = { }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1': rs(set([Demo(1, 1, 1)]))}
    True
    >>> toApply == { }
    True
    >>> lost == { }
    True

Verify the old baseline has been updated::

    >>> conduit.getRecordSet('1') == rs(set([Demo(1,1,1)]))
    True

Merge in an inbound change (no outbound changes)::

    >>> rsNewBase = { }
    >>> inboundDiff = { '1' : rs([Demo(1, 1, 2)]) }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == {'1': rs(set([Demo(1, nc, 2)]))}
    True
    >>> lost == { }
    True
    >>> conduit.getRecordSet('1') == rs(set([Demo(1,1,2)]))
    True

Merge non-overlapping inbound and outbound changes::

    >>> rsNewBase =   { '1' : rs([Demo(1, 3, 2)]) }
    >>> inboundDiff = { '1' : rs([Demo(1, 1, 3)]) }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1': rs(set([Demo(1, 3, 3)]))}
    True
    >>> toApply == {'1': rs(set([Demo(1, nc, 3)]))}
    True
    >>> lost == { }
    True
    >>> conduit.getRecordSet('1') == rs(set([Demo(1,3,3)]))
    True

Merge overlapping and non-overlapping inbound and outbound changes::

    >>> rsNewBase =   { '1' : rs([Demo(1, 4, 4)]) }
    >>> inboundDiff = { '1' : rs([Demo(1, 5, 3)]) }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1': rs(set([Demo(1, 5, 4)]))}
    True
    >>> toApply == {'1': rs(set([Demo(1, 5, nc)]))}
    True
    >>> lost == {'1': rs(set([Demo(1, 4, nc)]))}
    True
    >>> conduit.getRecordSet('1') == rs(set([Demo(1,5,4)]))
    True

Merge only overlapping inbound and outbound changes::

    >>> rsNewBase =   { '1' : rs([Demo(1, 5, 6)]) }
    >>> inboundDiff = { '1' : rs([Demo(1, 5, 7)]) }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == {'1': rs(set([Demo(1, nc, 7)]))}
    True
    >>> lost == {'1': rs(set([Demo(1, nc, 6)]))}
    True
    >>> conduit.getRecordSet('1') == rs(set([Demo(1,5,7)]))
    True

Add in a filter, make a local change and no inbound changes::

    >>> conduit.filters = ['cid:bar-filter@osaf.us']
    >>> rsNewBase = { '1' : rs([Demo(1, 6, 8)]) }
    >>> inboundDiff = { }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1': rs(set([Demo(1, 5, 8)]))}
    True
    >>> conduit.getRecordSet('1') == rs(set([Demo(1,5,8)]))
    True

Even though we locally modified the 'bar' field, the outbound record still
contains the previous, externally seen value.

There can be multiple filters in effect; note how the outbound record hasn't
changed at all::

    >>> conduit.filters = ['cid:bar-filter@osaf.us', 'cid:baz-filter@osaf.us']
    >>> rsNewBase = { '1' : rs([Demo(1, 7, 9)]) }
    >>> inboundDiff = { }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {}
    True
    >>> conduit.getRecordSet('1') == rs(set([Demo(1,5,8)]))
    True

Verify that inbound changes to filtered fields are not applied locally::

    recordset_conduit.STOP = True
    >>> conduit.filters = ['cid:bar-filter@osaf.us']
    >>> rsNewBase = { }
    >>> inboundDiff = { '1' : rs([Demo(1, 6, 8)]) }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == { }
    True
    >>> conduit.getRecordSet('1') == rs(set([Demo(1,6,8)]))
    True

Verify that inbound changes to unfiltered fields (when filters are active)
are applied locally::

    >>> conduit.filters = ['cid:bar-filter@osaf.us']
    >>> rsNewBase = { }
    >>> inboundDiff = { '1' : rs([Demo(1, 6, 9)]) }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == {'1': rs(set([Demo(1, nc, 9)]))}
    True
    >>> conduit.getRecordSet('1') == rs(set([Demo(1,6,9)]))
    True

Verify that inbound and outbound changes to a filtered field is not considered
a conflict::

    >>> rsNewBase =   { '1' : rs([Demo(1, 7, 9)]) }
    >>> inboundDiff = { '1' : rs([Demo(1, 8, 9)]) }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == { }
    True
    >>> lost == { }
    True
    >>> conduit.getRecordSet('1') == rs(set([Demo(1,8,9)]))
    True

Verify that conflicts can still be detected when at least one conflicting
field is not filtered::

    >>> rsNewBase =   { '1' : rs([Demo(1, 9, 10)]) }
    >>> inboundDiff = { '1' : rs([Demo(1, 10, 11)]) }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == {'1': rs(set([Demo(1, nc, 11)]))}
    True
    >>> lost == {'1': rs(set([Demo(1, nc, 10)]))}
    True
    >>> conduit.getRecordSet('1') == rs(set([Demo(1,10,11)]))
    True

Verify that a missing inbound record is applied as a deletion::

    >>> rsNewBase =   { }
    >>> inboundDiff = { '1' : rs() }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == {'1': rs(set([]), set([Demo(1, nc, 11)]))}
    True
    >>> lost == {}
    True
    >>> conduit.getRecordSet('1') == rs()
    True

Start over, adding two records (one of a new record type)::

    >>> class Demo2(sharing.Record):
    ...     URI = 'cid:eim.test.demo2-record@osaf.us'
    ...     foo = sharing.key(int)
    ...     bar = sharing.field(int, [barFilter])
    ...     baz = sharing.field(int, [bazFilter])

    >>> conduit.filters = []
    >>> rsNewBase =   { '1' : rs([Demo(1, 1, 1), Demo2(1, 2, 2)]) }
    >>> inboundDiff = { }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1': rs(set([Demo(1, 1, 1), Demo2(1, 2, 2)]))}
    True
    >>> conduit.getRecordSet('1') == rs(set([Demo(1,1,1), Demo2(1,2,2)]))
    True

...now remove the Demo(1,1,1), and the result of the merge will be that we
will send only the remaining record::

    >>> rsNewBase =   { '1' : rs(set([Demo2(1,2,2)])) }
    >>> inboundDiff = { }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1' : rs(set([Demo2(1,2,2)])) }
    True
    >>> conduit.getRecordSet('1') == rs(set([Demo2(1,2,2)]))
    True

If a record is removed inbound and outbound, that is not a conflict.  Note
that a double-deletion results in an unnecessary record deletion in toApply,
but record adding and deleting need to be idempotent anyway, so it's ok::

    >>> rsNewBase =   { '1' : rs() }
    >>> inboundDiff =   { '1' : rs() }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == { }
    True
    >>> toApply == {'1' : rs(set([]), set([Demo2(1,2,2)]))} # will be a no-op
    True
    >>> lost == { }
    True
    >>> conduit.getRecordSet('1') == rs()
    True



Set up a conduit, with a filter this time from the start::

    >>> conduit = recordset_conduit.RecordSetConduit(itsView=rv)
    >>> conduit.filters = ['cid:bar-filter@osaf.us']

Merge a local addition with no inbound changes; note that the outbound
record has a NoChange value on the filtered field::

    >>> rsNewBase = { '1' : rs([Demo(1, 1, 1)]) }
    >>> inboundDiff = { }
    >>> toSend, toApply, lost = conduit.merge(rsNewBase, inboundDiff)
    >>> toSend == {'1': rs(set([Demo(1, nc, 1)]))}
    True
