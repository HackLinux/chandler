=========================
Schema Definition Support
=========================

.. contents:: **Table of Contents**

    >>> from application import schema
    >>> from chandlerdb.persistence.RepositoryView import NullRepositoryView


------------------
Descriptor Objects
------------------

The ``Descriptor`` Base Type
=============================

The base class for roles is ``schema.Descriptor``.  It provides most of the
default behavior of descriptors, so rather than duplicate examples for each
individual role type, we'll examine the default behaviors here.

All role objects have at least the following attributes and methods:

``name`` (read-only)
    The name under which this role was first defined in an entity class or
    relationship, or ``None`` if the role has not been registered with a
    class yet::

        >>> role = schema.Descriptor()
        >>> print role.name
        None
        >>> class anEntity(schema.Item):
        ...     aDescriptor = role
        >>> role.name
        'aDescriptor'


``owner`` (read-only)
    The entity or relationship class in which the role was defined, or ``None``
    if the role has not been registered with a class yet::

        >>> role = schema.Descriptor()
        >>> print role.owner
        None
        >>> class anEntity(schema.Item):
        ...     aDescriptor = role
        >>> role.owner
        <class '...anEntity'>

    If a role's owner is an ``Item`` class, then setting
    ``aDescriptor.inverse`` will invoke
    ``aDescriptor.inverse.addType(aDescriptor.owner)``, so that the inverse
    role will accept instances of the first role's owning type. This allows you
    to easily define bidirectional links without "forward references"; just
    leave off the `type` argument in both role definitions, and specify an
    `inverse` argument for the second::

        >>> class anotherEntity(schema.Item):
        ...     otherDescriptor=schema.Descriptor(inverse=anEntity.aDescriptor)
        >>> anotherEntity.otherDescriptor.type
        <class '...anEntity'>
        >>> anEntity.aDescriptor.type
        <class '...anotherEntity'>

    As you can see, this ensures that both roles can accept the owning type of
    the other role.  It also works for setting up self-recursive roles within a
    single type::

        >>> class Kind(schema.Item):
        ...     name = schema.One(schema.Text)
        ...     subkinds = schema.Many()
        ...     superkinds = schema.Many(inverse=subkinds)
        ...     def __repr__(self):
        ...         return getattr(self,'name',object.__repr__(self))

        >>> Kind.subkinds.type
        <class '...Kind'>
        >>> Kind.superkinds.type
        <class '...Kind'>

``description``, and ``doc``
    The name and description of this role, if any.  They will be used to
    collectively form a ``__doc__`` string, so that ``help()`` is informative
    for Item classes::

        >>> Kind.subkinds.doc = "Sub-kinds of this kind"
        >>> Kind.superkinds.doc = "Super-kinds of this kind"
        >>> Kind.name.doc = "This kind's name"

        >>> help(Kind)  # doctest: +NORMALIZE_WHITESPACE
        Help on class Kind ...
        ...
        class Kind(application.schema.Item)
         |  Method resolution order:
         |      Kind
         |      application.schema.Item
         |      chandlerdb.item.Item.Item
         |      chandlerdb.item.c.CItem
         |      __builtin__.object
         |  
         |  Methods defined here:
         |  
         |  __repr__(self)
         |  
         |  ...
         |  Data descriptors defined here:
         |
         |  name
         |      One(Text)
         |
         |      This kind's name
         |
         |  subkinds
         |      Many(Kind)
         |
         |      Sub-kinds of this kind
         |
         |  superkinds
         |      Many(Kind)
         |
         |      Super-kinds of this kind
         |  ...

    Note: ``doc`` is a shortcut for ``description``; there is no difference
    between the two attributes::

        >>> Kind.name.doc is Kind.name.description
        True

    The ``doc`` and ``description`` are always strings, even if empty::

        >>> schema.Descriptor().description
        ''

``inverse``
    The role object that represents the "other side" of the relationship, or
    ``None`` if not yet set.  Setting a role's inverse automatically attempts
    to set the reverse role, so that each role's ``inverse`` attribute points
    to the other.  Thus, you do not have to set both roles' ``inverse``
    attributes in order to link them together.

    ``inverse`` can be set via keyword argument to the role class'
    constructor::

        >>> role1 = schema.Descriptor()
        >>> print role1.inverse
        None
        >>> role2 = schema.Descriptor(inverse=role1)
        >>> role2.inverse is role1
        True
        >>> role1.inverse is role2
        True

    Or by setting the ``inverse`` attribute after construction::

        >>> role1 = schema.Descriptor()
        >>> role2 = schema.Descriptor()
        >>> role2.inverse = role1
        >>> role2.inverse is role1
        True
        >>> role1.inverse is role2
        True

    Once set, it cannot be changed, unless it is to the same role::

        >>> role2.inverse = schema.Descriptor()
        Traceback (most recent call last):
        ...
        TypeError: Descriptor objects are immutable; can't change 'inverse' ...

        >>> role2.inverse is role1      # no change took place
        True

    And trying to insert a new role into an existing pair also fails::

        >>> role3 = schema.Descriptor()
        >>> print role3.inverse
        None
        >>> role3.inverse = role2
        Traceback (most recent call last):
        ...
        TypeError: Descriptor objects are immutable; can't change 'inverse' ...

        >>> print role3.inverse         # no change took place
        None

    Forward-referencing roles must leave their type information undefined::

        >>> class File(schema.Item):
        ...     folder = schema.One()
        >>> class Folder(File):
        ...     contents = schema.Many(inverse=File.folder)

    Notice that the second attribute uses normal references instead of forward
    references.  This ensures that the forward references are resolved::

        >>> File.folder.type
        <class '...Folder'>

        >>> File.folder.inverse
        <Descriptor contents of <class '...Folder'>>

``type``
    The ``type`` of a role can be either a ``schema.Item`` subclass, a
    ``schema.TypeReference`` to a specific repository value type, or a string
    (which is automatically converted to a ``schema.ForwardReference``).  The
    ``schema`` module supplies various pre-configured ``TypeReference``
    objects for your convenience::

        >>> schema.Text
        TypeReference('//Schema/Core/Text')

        >>> myType = schema.TypeReference('//Schema/Core/DateTime')

        >>> print schema.Descriptor(myType).__doc__
        Descriptor(DateTime)

    Note that you cannot use arbitrary Python types or classes; you must either
    supply a ``schema.TypeReference``, a subclass of ``schema.Item``, or a
    string representing a forward reference::

        >>> schema.Descriptor(str)
        Traceback (most recent call last):
        ...
        TypeError: ('...must be Item/Enumeration class or TypeReference',...)


Aspect Attributes
    Descriptor objects support setting all of the aspects of a repository
    ``Attribute``, including ``required``, ``persisted``, ``indexed``,
    ``cardinality``, ``defaultValue``, ``initialValue``, ``inheritFrom``,
    ``otherName``, ``companion``, ``deletePolicy``,
    ``copyPolicy``, ``countPolicy``, ``type``, ``superAttribute``, and
    ``description``.  You can supply any of these as
    keyword arguments to a Descriptor constructor (such as ``schema.One``,
    ``schema.Many``, etc.), in order to set the corresponding value for the
    attribute.  Unspecified aspects will take on their normal default values,
    except for ``otherName``, which is set to ``inverse.name`` by default, if
    the attribute has an inverse.


To avoid silent definition errors, ``Descriptor`` classes will not allow
setting attributes that are not defined by their class::

    >>> r = schema.Descriptor(foo="bar")
    Traceback (most recent call last):
    ...
    TypeError: 'foo' is not a public attribute of 'Descriptor' objects

And, to avoid unintentional alterations, Descriptor attributes can be set only
once::

    >>> r = schema.Descriptor(doc="x")
    >>> r.doc = "testing"
    Traceback (most recent call last):
      ...
    TypeError: Descriptor objects are immutable; can't change 'doc'... once set


Change Notifications
====================

Test error messages:

    >>> class Example(schema.Item):
    ...     foo = schema.One(schema.Integer)
    ...     @schema.observer(foo)
    ...     def __foo_changed(self, op, name):
    ...         print name, "changed"
    >>> rv = NullRepositoryView(verify=True)
    >>> e = Example(itsView = rv)
    >>> e.foo = 1
    foo changed

    >>> class Example2(schema.Item):
    ...     @schema.observer(Example.foo)
    ...     def foo_changed(self, op, name):
    ...         print name, "changed"
    Traceback (most recent call last):
      ...
    TypeError: ...foo... does not belong to ...Example2'> or its superclasses

    >>> class Example2(Example):
    ...     @schema.observer(Example.foo)
    ...     def _Example__foo_changed(self, op, name):
    ...         print name, "changed in Example2"
    >>> e2 = Example2(itsView = rv)
    >>> e2.foo = 1
    foo changed in Example2

    >>> class BadExample(schema.Item):
    ...     @schema.observer("foo")
    ...     def foo_changed(self, op, name):
    ...         print name, "changed"
    Traceback (most recent call last):
      ...
    TypeError: 'foo' is not a schema.Descriptor (One, Many, Sequence, etc.)

Test observers on Annotations:

   >>> class ExampleAnnotation(schema.Annotation):
   ...     schema.kindInfo(annotates=schema.Item)
   ...     blat = schema.One(schema.Integer)
   ...     @schema.observer(blat)
   ...     def blat_changed(self, op, name):
   ...         print "%s changed (%s) in ExampleAnnotation" % (name, op)
    >>> rv = NullRepositoryView(verify=True)
    >>> e = ExampleAnnotation(schema.Item(itsView = rv))
    >>> e.blat = 1
    application.tests.ExampleAnnotation.blat changed (set) in ExampleAnnotation
    >>> del e.blat
    application.tests.ExampleAnnotation.blat changed (remove) in ExampleAnnotation

   >>> class ExampleAnnotation2(schema.Annotation):
   ...     schema.kindInfo(annotates=schema.Item)
   ...     blat = schema.One(schema.Integer)
   ...     @schema.observer(blat)
   ...     def __blat_changed(self, op, name):
   ...         print "%s changed (%s) in ExampleAnnotation2" % (name, op)
    >>> rv = NullRepositoryView(verify=True)
    >>> e = ExampleAnnotation2(schema.Item(itsView = rv))
    >>> e.blat = 1
    application.tests.ExampleAnnotation2.blat changed (set) in ExampleAnnotation2



---------------
Item Subclasses
---------------

XXX Explain this::

    >>> rv = NullRepositoryView(verify=True)


    >>> class Person(schema.Item):
    ...     fullname = schema.One(schema.Text)
    ...     age = schema.One(schema.Integer)
    ...     parents = schema.Sequence()
    ...     children = schema.Sequence(inverse=parents)
    ...
    ...     schema.addClouds(
    ...         # endpoints can be defined using Descriptor objects or strings
    ...         sharing = schema.Cloud(byCloud=[parents,children]),
    ...         export = schema.Cloud(byRef=["children"]),
    ...     )
    ...     def __repr__(self): return self.fullname

    >>> Joe = Person('Joe', None, None, rv, fullname=u"Joe Schmoe", age=39)
    >>> Joe
    Joe Schmoe

    >>> Mary = Person('Mary', rv, children=[Joe], fullname=u"Mary Quite Contrary")
    >>> list(Joe.parents)
    [Mary Quite Contrary]

Items created without an explicit "parent" have a repository parent of
``//userdata``::

    >>> Joe.itsParent
    <Item ... userdata ...>

    >>> Joe.itsParent.itsPath
    //userdata

Unless you set a ``__default_path__`` in your class, which is used to find
and/or create a default parent::

    >>> class Elsewhere(schema.Item):
    ...     __default_path__ = "//userdata/miscellaneous"

    >>> thingy = Elsewhere(None, None, None, rv)
    >>> thingy.itsParent.itsPath
    //userdata/miscellaneous

    >>> thingy.itsParent is Elsewhere.getDefaultParent(rv)
    True


Clouds are associated with the class' kind, with names that are generated
by capitalizing the cloud alias and adding 'Cloud' to them (matching previous
OSAF naming conventions)::

    >>> clouds = schema.itemFor(Person, rv).clouds
    >>> list(clouds)
    [<Cloud ... SharingCloud ...>, <Cloud ... ExportCloud ...>]

    >>> sharing = clouds.getByAlias('sharing')
    >>> list(sharing.endpoints)
    [<Endpoint ... parents ...>, <Endpoint ... children ...>]

    >>> parents = sharing.endpoints.getByAlias('parents')
    >>> parents.includePolicy
    'byCloud'
    >>> parents.attribute
    <PersistentList: ['parents']>

    >>> export = clouds.getByAlias('export')
    >>> list(export.endpoints)
    [<Endpoint ... children ...>]

    >>> children = export.endpoints.getByAlias('children')
    >>> children.includePolicy
    'byRef'
    >>> children.attribute
    <PersistentList: ['children']>

Instances of an item class can be iterated over using the ``iterItems()`` class
method::

    >>> sorted(Person.iterItems(rv), key=lambda x:x.fullname)
    [Joe Schmoe, Mary Quite Contrary]

If no view is specified, the schema API's null repository view is searched, but
you can also specify a particular view::

    >>> rep = NullRepositoryView()
    >>> schema.initRepository(rep)
    >>> list(Person.iterItems(rep))
    []

By default, subclass instances are included in the results::

    >>> class StrangePerson(Person): pass
    >>> stranger = StrangePerson(None,None,None,rv,fullname=u"The Stranger")
    >>> sorted(Person.iterItems(rv), key=lambda x:x.fullname)
    [Joe Schmoe, Mary Quite Contrary, The Stranger]

But you can turn this off by setting ``exact=True``, so that only instances
of the exact class are yielded::

    >>> sorted(Person.iterItems(rv,exact=True), key=lambda x:x.fullname)
    [Joe Schmoe, Mary Quite Contrary]


Anonymous Inverses
==================

Sometimes, you need a bidirectional reference between a new kind and an
existing kind.  You can do this by creating an "anonymous inverse" - a
role that just indicates the cardinality of the other end (optionally with
a description, initialValue, or other options):


    #>>> __name__ = "application.tests"    # pretend we're in this parcel

    >>> class School(schema.Item):
    ...     attendees = schema.Sequence(Person, inverse=schema.One())

    >>> joes_school = School("Hogwart's",None,None,rv,attendees=[Joe])
    >>> list(joes_school.attendees)
    [Joe Schmoe]

The inverse attribute will live in the repository under the School kind::

    >>> schema.itemFor(School.attendees.inverse, rv).itsPath
    //parcels/application/tests/School/application.tests.School.attendees.inverse

But it will be an attribute of the Person kind::

    >>> sorted(
    ...     a.itsName for a in Person.getKind(rv).attributes
    ... ) # doctest: +NORMALIZE_WHITESPACE
    ...
    ['age', 'application.tests.School.attendees.inverse', 'children',
     'fullname', 'parents']

Notice that the attribute name is a combination of:

1. the parcel name (from the module's ``__parcel__``, if applicable)
2. the class name where the attribute was defined
3. the name of the attribute within the class
4. The word ``inverse``

You can use this constructed name with standard APIs to retrieve its value from
items of the target kind::

    >>> getattr(Joe, 'application.tests.School.attendees.inverse')
    <School ... Hogwart's ...>

    >>> delattr(Joe, 'application.tests.School.attendees.inverse')
    >>> list(joes_school.attendees)
    []

    #>>> del __name__    # quit pretending we're in application.tests


Annotation Classes
==================

Chandler types can be extended to add new attributes not envisioned by their
creators, using ``schema.Annotation`` classes.  Here, we'll define a
"Teacher" annotation class that adds "annotation attributes" to "Person"::

    >>> __name__ = "application.tests"    # pretend we're in this parcel

    >>> class Teacher(schema.Annotation):
    ...     schema.kindInfo(annotates=Person)   # annotate the "Person" type
    ...     certifications = schema.Sequence()
    ...     supervisor = schema.One(Person)

    >>> class TeachingCertificate(schema.Item):
    ...     subject = schema.One(schema.Text)
    ...     certified_teachers = schema.Sequence(
    ...         Teacher, inverse=Teacher.certifications
    ...     )

Annotation classes do not create persistent items.  Instead, their instances
are wrappers that give you access to the annotation attributes, which are
actually stored on the wrapped item::

    >>> ProfMary = Teacher(Mary)
    >>> gym = TeachingCertificate("gym", rv, subject=u"Physical Education")
    >>> ProfMary.certifications = [gym]
    >>> list(ProfMary.certifications)
    [<TeachingCertificate ... gym ...>]

    >>> list(gym.certified_teachers)
    [Mary Quite Contrary]

As you can see, you can set or get attributes on the "Teacher" object, that
will actually be stored in the "Mary" item.  Because the annotation wrapper
delegates all the attribute storage to the underlying "Person", you can create
as many wrappers as you want for a given item and they will all share the same
attribute values::

    >>> list(Teacher(Mary).certifications)
    [<TeachingCertificate ... gym ...>]

These additional attributes are added to the annotated kinds, using their
module/class names to distinguish them from "native" or "essential" attributes
of the kind::

    >>> sorted(
    ...     a.itsName for a in Person.getKind(rv).attributes
    ... ) # doctest: +NORMALIZE_WHITESPACE
    ...
    ['age', 'application.tests.School.attendees.inverse',
     'application.tests.Teacher.certifications',
     'application.tests.Teacher.supervisor', 'children', 'fullname', 'parents']

So you can still get to these attributes without using the Annotation wrapper,
as long as you use the fully-qualified attribute name::

    >>> list(getattr(Mary,'application.tests.Teacher.certifications'))
    [<TeachingCertificate ... gym ...>]

And setting or deleting the attribute on either the underlying item (full name)
or the annotation wrapper (short name) has identical effects::

    >>> setattr(Mary, 'application.tests.Teacher.supervisor', Joe)
    >>> ProfMary.supervisor
    Joe Schmoe

    >>> del ProfMary.supervisor
    >>> hasattr(Mary, 'application.tests.Teacher.supervisor')
    False

You cannot assign arbitrary attributes to annotation instances, only ones
that were defined in its schema, or by using ``__slots__`` in the class
definition::

    >>> ProfMary.foo = "bar"
    Traceback (most recent call last):
      ...
    AttributeError: 'Teacher' object has no attribute 'foo'

    >>> class Friend(schema.Annotation):
    ...     __slots__ = ["jabberConnection"]
    ...     schema.kindInfo(annotates=Person)
    ...     likes = schema.Sequence()
    ...     isLikedBy = schema.Sequence(inverse=likes)

    >>> Friend(Mary).isLikedBy = [Joe]
    >>> list(Friend(Joe).likes)
    [Mary Quite Contrary]

Note, however, that variables defined in ``__slots__`` are *transient*; they
will not be stored in the repository.  They also are per-annotation instance,
not per underlying item::

    >>> fMary = Friend(Mary)
    >>> fMary.jabberConnection = "just pretending"
    >>> fMary.jabberConnection
    'just pretending'

    >>> f2Mary = Friend(Mary)
    >>> f2Mary.jabberConnection
    Traceback (most recent call last):
      ...
    AttributeError: jabberConnection

Annotation class instances must wrap an instance of the type they were defined
as annotating::

    >>> Teacher(gym)
    Traceback (most recent call last):
      ...
    TypeError: <class '...Teacher'> requires a <class '...Person'> instance but got a <class '...TeachingCertificate'> instance

or an instance of another annotation wrapping an instance of the appropriate
type.  Thus, we can convert a ``Friend`` to a ``Teacher`` or vice versa::

    >>> Teacher(fMary)
    Teacher(Mary Quite Contrary)

    >>> Friend(ProfMary)
    Friend(Mary Quite Contrary)

    >>> Friend(Teacher(Friend(Friend(ProfMary))))
    Friend(Mary Quite Contrary)

Finally, if you need to get at the annotated item of an annotation instance,
you can use the ``itsItem`` attribute::

    >>> fMary.itsItem
    Mary Quite Contrary


    >>> del __name__    # CLEANUP (quit pretending we're in application.tests)


Enumerations
============

    >>> class Importance(schema.Enumeration):
    ...     schema.kindInfo(description="Importance Enum")
    ...     values = 'high', 'medium', 'low'

    >>> imp = schema.itemFor(Importance, rv)
    >>> imp
    <Enumeration ... Importance ...>

    >>> imp.description
    'Importance Enum'

    >>> test_role = schema.Descriptor(Importance)

    >>> imp.values
    <PersistentList: ['high', 'medium', 'low']>

    >>> class Rating(Importance):
    ...     values = "good", "bad"
    Traceback (most recent call last):
      ...
    TypeError: Enumerations cannot subclass or be subclassed

    >>> class BrokenEnum(schema.Enumeration):
    ...     values = "error"
    Traceback (most recent call last):
      ...
    TypeError: 'values' must be a tuple of 1 or more strings or a dict of (str, value) pairs

    >>> class BrokenEnum2(schema.Enumeration):
    ...     values = ["x", "y"]
    Traceback (most recent call last):
      ...
    TypeError: 'values' must be a tuple of 1 or more strings or a dict of (str, value) pairs

    >>> class BrokenEnum2(schema.Enumeration):
    ...     values = ()
    Traceback (most recent call last):
      ...
    TypeError: 'values' must be a tuple of 1 or more strings or a dict of (str, value) pairs

    >>> class BrokenEnum3(schema.Enumeration):
    ...     def foo(self): pass
    Traceback (most recent call last):
      ...
    TypeError: ("Only 'values' or 'names' may be defined in an enumeration class", 'foo', <function foo ...>)

    >>> class BadMetadata(schema.Enumeration):
    ...     schema.kindInfo(displayAttribute="xyz")
    ...     values = 'one', 'two'
    Traceback (most recent call last):
      ...
    TypeError: 'displayAttribute' is not an attribute of Enumeration



Structs
=======

    >>> class Size(schema.Struct):
    ...     __slots__ = 'width', 'height'

    >>> Size(1,2).width
    1
    >>> Size(1,2).height
    2
    >>> Size(3,4)
    Size(3, 4)

    >>> Size(4,5,6)
    Traceback (most recent call last):
      ...
    TypeError: ('Unexpected arguments', (6,))

    >>> class Wrong(Size): pass
    Traceback (most recent call last):
      ...
    TypeError: Structs cannot subclass or be subclassed

    >>> schema.itemFor(Size, rv)
    <SchemaStruct ... Size ...>

    >>> schema.itemFor(Size, rv).itsKind.itsPath
    //Schema/Core/Struct


Abstract Classes
================

You can make an ``Item`` subclass abstract (non-instantiable) by setting
``__abstract__ = True`` in its class body::

    >>> class Thing(schema.Item):
    ...     __abstract__ = True

    >>> Thing()
    Traceback (most recent call last):
      ...
    TypeError: Thing is an abstract class; use a subclass instead

But subclasses of an abstract class are instantiable in the normal way::

    >>> class Chair(Thing):
    ...     pass

    >>> Chair('chair',rv)
    <Chair ...>


--------------------
Parcel-Loading Tools
--------------------

Namespaces
==========

When creating a lot of items that refer to existing items in other parcels,
it's sometimes useful to be able to refer to both classes and instances in
those parcels as if they were in a single namespace.  The ``schema.ns`` class
lets you create such namespaces.

You create a namespace by passing a module name and repository view to
``schema.ns()``.  We're using the null repository view, so we can omit the
view::

    >>> api_tests = schema.ns("application.tests.TestSchemaAPI", rv)

We now have an object that can be used to access items that are directly in
the designated module::

    >>> api_tests.test_schema_api
    <function test_schema_api at ...>

A namespace's ``parcel`` attribute is the parcel in the designated view that
corresponds to the named module::

    >>> api_tests.parcel
    <Parcel (new): TestSchemaAPI ...>

This is probably also a good time to point out that you can create a namespace
using any item, not just a repository view, e.g.::

    >>> other_ns = schema.ns("application.tests", api_tests.parcel)
    >>> other_ns.TestSchemaAPI
    <module 'application.tests.TestSchemaAPI' ...>

If we create an item in that parcel, it will then be accessible by name from
the namespace::

    >>> aPerson = Person("Smitty", api_tests.parcel)
    >>> api_tests.Smitty is aPerson
    True

But not if there is an object of the same name defined in the module::

    >>> aPerson.itsName = "test_schema_api"
    >>> api_tests.test_schema_api   # obscured by the function in the module
    <function test_schema_api at ...>

You can still access it via the parcel, if you need to, but it's not
recommended that you have module contents and items with the same name::

    >>> api_tests.parcel.getItemChild("test_schema_api") is aPerson
    True


Installing or Updating Items
============================

If you're creating items in your parcel's ``installParcel()`` function, you
will probably want to update any previously-installed items with any changed
data, but also create new items that didn't exist before.  The ``update()``
method of ``schema.Item`` subclasses allows you to specify what data an item
should have, and then either update the old item or create a new one.

To use this method, you must supply a parcel and name to the ``update()``
method of the class of item you want to create.  For example::

    >>> def installParcel(parcel, old_version=None):
    ...     Person.update(parcel, "Carlos", fullname=u"Carlos Marron")

At the moment, there is no "Carlos" in the api_tests parcel::

    >>> api_tests.Carlos    # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
    ...
    AttributeError: Carlos is not in <module 'application.tests.TestSchemaAPI'
    from ...> or <Parcel ...: TestSchemaAPI ...>

So, we'll create him::

    >>> installParcel(api_tests.parcel)
    >>> api_tests.Carlos
    Carlos Marron

Now, let's change his name, and see what happens if we "update" the parcel::

    >>> carlos = api_tests.Carlos
    >>> carlos.fullname = u"Charlie Brown"
    >>> carlos.fullname
    u'Charlie Brown'

    >>> installParcel(api_tests.parcel)
    >>> carlos.fullname
    u'Carlos Marron'

Notice that on our second call, the object's fullname attribute was updated
*in place*, instead of creating a new item.  Also, the kind and class are
updated, too::

    >>> carlos.itsKind = StrangePerson.getKind(rv)
    >>> type(carlos)
    <class '...StrangePerson'>

    >>> installParcel(api_tests.parcel)
    >>> type(carlos)
    <class '...Person'>

Note that the ``update()`` method can't tell if you've renamed an object that
should have the same name, or whether perhaps you've accidentally given two
objects the same name, so you need to check these things yourself.  If you
need to delete old items or rename/relocate items in your ``installParcel()``
function, you should just use the normal repository APIs to do so.


Forward References
==================

Sometimes, a complex item structure may require forward references, to items
that do not yet exist.  To support this, parcel and namespace objects provide
a ``fwdRef()`` method that will return a named item in that parcel or
namespace, even if no item currently exists with that name.  As long as the
forward reference is resolved (by using ``update()`` to actually create the
item) by the time ``schema.assertResolved()`` is called, no error will occur.
However, if outstanding forward references exist, then an error is raised,
showing the original files and line numbers where the forward references were
created.

Let's create a forward reference to a person::

    >>> stranger = api_tests.fwdRef(Person, u'Stranger')

At this point, the item exists and can be used::

    >>> carlos.parents = [stranger]
    >>> list(stranger.children)
    [Carlos Marron]

But the view knows it has unresolved references::

    >>> schema.assertResolved(api_tests.parcel)
    Traceback (most recent call last):
      ...
    NameError: Unresolved forward references:
    ...
        //parcels/application/tests/TestSchemaAPI/Stranger:
            <doctest schema_api.txt[...]> line 1
    ...

But actually updating the object will resolve the forward reference::

    >>> Person.update(api_tests.parcel, 'Stranger', fullname=u"Stranger")
    Stranger

    >>> schema.assertResolved(api_tests.parcel)     # no more errors


--------------------
Schema API Internals
--------------------

Importing the ``application.schema`` module automatically loads the core and
Chandler schema packs into the null repository view, if they aren't already
loaded::

    >>> rv.findPath('//Schema/Core/Parcel')
    <Kind ...>


``importString(moduleName)``
    Imports the named module (or named item within a module)::

        >>> import sys
        >>> schema.importString("sys") is sys
        True

        >>> schema.importString("application.tests")
        <module 'application.tests' from '...'>

        >>> import application.tests
        >>> schema.importString("application.tests") is application.tests
        True


``parcel_for_module(moduleName, rv)``
    The ``parcel_for_module()`` API returns a parcel instance for the named
    module.  If the module has a ``__parcel__`` attribute, the parcel for
    the named module is returned instead::

        >>> nrv = NullRepositoryView()

        >>> application.tests.__parcel__ = "__builtin__"
        >>> schema.parcel_for_module("application.tests", nrv)
        <Parcel ... __builtin__ ...>

        >>> del application.tests.__parcel__    # clean up after the above test

    If the module has no ``__parcel__``, but it has an ``installParcel()``
    function, it will be called::

        >>> def installParcel(parcel, old_version=None):
        ...     print "installParcel(",parcel,")"
        >>> application.tests.installParcel = installParcel

        >>> nrv = NullRepositoryView()
        >>> schema.parcel_for_module("application.tests", nrv)
        installParcel( <Parcel (new): tests ...> )
        <Parcel (new): tests ...>

    As you can see, the global lock is acquired during the recursive creation
    or retrieval of the parcel object, and released afterwards.

    The created parcel object is cached by the schema API so that subsequent
    invocations just return the same object, without recreating it::

        >>> schema.parcel_for_module("application.tests", nrv)
        <Parcel (new): tests ...>

        >>> # clean up dummy parcel setup
        >>> del application.tests.installParcel

    Finally, in order to support defining core schema kinds using the schema
    API, you can set ``__parcel__`` to a string starting with ``//``) in order
    to make the module's classes define kinds as children of that repository
    path (which must exist, and must NOT contain any ``.`` characters).  This
    is something of a kludge, and should be replaced with a more robust
    mechanism if we start moving more of the core schema into the schema API::

        >>> nrv = NullRepositoryView()
        >>> application.tests.__parcel__ = "//Schema/Core"
        >>> schema.parcel_for_module("application.tests", nrv)
        <Item ...: Core ...>

        >>> del application.tests.__parcel__    # clean up after the above test


``itemFor(obj, rv)``
    Return the repository item that corresponds to the supplied object.  For
    example, ``itemFor(AnItemClass)`` returns the repository ``Kind`` that
    represents that class in the null view::

        >>> schema.itemFor(schema.Item, rv)
        <Kind ... Item ...>

        >>> class TestItem(schema.Item):
        ...     __module__ = 'application.tests'  # pretend we're here

        >>> schema.itemFor(TestItem, rv)
        <Kind ... TestItem ...>

        >>> kind = schema.itemFor(TestItem, rv)

    And the generated kind has its class' module's parcel as its parent::

        >>> kind.itsParent is schema.parcel_for_module('application.tests', rv)
        True

        >>> kind is rv.findPath('//parcels/application/tests/TestItem')
        True

    Its superkinds are the ``schema.itemFor()`` of its base classes::

        >>> list(kind.superKinds) == [rv.findPath('//Schema/Core/Item')]
        True

    Its kind is of course ``Kind``::

        >>> kind.itsKind is rv.findPath('//Schema/Core/Kind')
        True

    And its class is the class::

        >>> kind.classes['python'] is TestItem
        True


    Meanwhile, ``schema.itemFor(aDescriptor)`` returns a repository ``Attribute``
    object representing that attribute in the null view::

        >>> schema.itemFor(Kind.subkinds, rv)
        <Attribute ... subkinds ...>

        >>> schema.itemFor(Kind.subkinds, rv).otherName
        'superkinds'

        >>> schema.itemFor(Kind.superkinds, rv).otherName
        'subkinds'

        >>> schema.itemFor(Kind.subkinds, rv).itsParent is schema.itemFor(Kind, rv)
        True

        >>> schema.itemFor(Kind.subkinds, rv) in schema.itemFor(Kind, rv).attributes
        True

        >>> schema.itemFor(Kind.subkinds, rv).cardinality
        'set'

        >>> schema.itemFor(Kind.subkinds, rv).description is Kind.subkinds.doc
        True

    Descriptors must be activated in a class, however, in order to generate their
    ``Attribute``::

        >>> schema.itemFor(schema.One(), rv)
        Traceback (most recent call last):
        ...
        TypeError: role object used outside of schema class

    And once a role's ``Attribute`` is generated, you cannot change any of its
    attributes any more::

        >>> Kind.subkinds.defaultValue = "xyz"
        Traceback (most recent call last):
        ...
        TypeError: Descriptor object <Descriptor subkinds of <class '...Kind'>> cannot be modified after use

``initRepository(repoView)``
    Ensure that the given repository view has been initialized with the core
    schemas for Chandler.

    >>> nrv = NullRepositoryView()
    >>> print nrv.findPath('//Schema/Core/Parcel')
    None

    >>> schema.initRepository(nrv)

    >>> nrv.findPath('//Schema/Core/Item')
    <Kind ... Item ...>


``synchronize(repoView, moduleName)``
    Ensure that the named module has been imported, and that its offered schema
    (if any) has been imported into the supplied repository view.

    >>> import application.tests
    >>> application.tests.__TestItem = TestItem
    >>> print nrv.findPath('//parcels/application/tests/TestItem')
    None
    >>> schema.synchronize(nrv, 'application.tests')
    >>> print nrv.findPath('//parcels/application/tests/TestItem')
    <Kind ... TestItem ...>

    >>> del application.tests.__TestItem


``fwdRef(parent, name, callerInfo=None)``
    Return an item with the given name and parent.  If the item did not exist,
    a new, kindless item is created, and is logged as an unresolved forward
    reference made by the caller::

        >>> testsParcel = schema.ns('application.tests',nrv).parcel
        >>> schema.fwdRef(testsParcel, 'TestItem')
        <Kind ... TestItem ...>

        >>> schema.fwdRef(testsParcel,'AnotherThing')
        <Item ... AnotherThing ...>

    ``callerInfo`` should be a ``(filename,line)`` tuple if supplied.  If not
    supplied, the filename and line number of the code that called this
    function will be logged as the source of the forward reference.

``resolveRef(parent, name)``
    Mark a forward reference as resolved, so it won't cause an error when
    ``schema.assertResolved(view)`` is called::

        >>> schema.resolveRef(testsParcel,'AnotherThing')

``assertResolved(view)``
    Check the view for unresolved forward references, and if any are present,
    raise an error listing them::

        >>> schema.assertResolved(nrv)   # nothing unresolved right now

        >>> schema.fwdRef(testsParcel,'BorkenRef')  # create unresolved ref
        <Item ... BorkenRef ...>

        >>> schema.assertResolved(nrv)
        Traceback (most recent call last):
          ...
        NameError: Unresolved forward references:
        ...
            //parcels/application/tests/BorkenRef:
                <doctest schema_api.txt[...]> line 1
        ...

    Note that unresolved references remain unresolved until they are marked
    resolved by ``resolveRef()``, and that each use of a forward reference
    is logged::

        >>> schema.fwdRef(testsParcel,'BorkenRef')  # use unresolved ref again
        <Item ... BorkenRef ...>

        >>> schema.fwdRef(testsParcel,'Sping')      # new unresolved ref
        <Item ... Sping ...>

        >>> schema.assertResolved(nrv)
        Traceback (most recent call last):
          ...
        NameError: Unresolved forward references:
        ...
            //parcels/application/tests/BorkenRef:
                <doctest schema_api.txt[...]> line 1
                <doctest schema_api.txt[...]> line 1
        ...
            //parcels/application/tests/Sping:
                <doctest schema_api.txt[...]> line 1
        ...

        >>> schema.resolveRef(testsParcel,'BorkenRef')
        >>> schema.assertResolved(nrv)
        Traceback (most recent call last):
          ...
        NameError: Unresolved forward references:
        ...
            //parcels/application/tests/Sping:
                <doctest schema_api.txt[...]> line 1
        ...

        >>> schema.resolveRef(testsParcel,'Sping')

        >>> schema.assertResolved(nrv)   # everything's resolved now


``getCaller(frame=None, level=2)``
    Return a ``(filename,line)`` tuple for the given frame or frame level.  By
    default, this will return the file and line for the code that called the
    routine that is calling this function (``level=2``)::

        >>> schema.getCaller()  # we're being called from doctest.py line 1212
        ('...doctest...', 12...)

        >>> schema.getCaller(level=1)   # where are we calling from?
        ('<doctest schema_api.txt[...]>', 1)

        >>> schema.getCaller(sys._getframe())   # same, but using frame arg
        ('<doctest schema_api.txt[...]>', 1)


Descriptor Activation
---------------------

Placing an instance of a ``schema.ActiveDescriptor`` subclass in a class whose
metaclass is a subclass of ``schema.Activator`` automatically activates it,
by calling its ``activateInClass`` method::

    >>> class MockAttr(schema.ActiveDescriptor):
    ...     def activateInClass(self,cls,name):
    ...         print "activated %r in %r" % (name,cls)

    >>> class Test1(object):
    ...     __metaclass__ = schema.Activator
    ...     aDescriptor = MockAttr()
    activated 'aDescriptor' in <class 'Test1'>

    >>> class Test2(Test1):
    ...     test = MockAttr()
    activated 'test' in <class 'Test2'>


"Foreign" Attributes
--------------------

A role object's ``annotates`` attribute lists items whose ``attributes`` the
role's ``Attribute`` instance should be added to when the ``Attribute`` is
created::

    >>> nrv = NullRepositoryView()
    >>> sorted(a.itsName for a in Person.getKind(nrv).attributes)  # doctest: +NORMALIZE_WHITESPACE
    ['age', 'children', 'fullname', 'parents']

    >>> class HealthInfo(schema.Item): pass
    >>> weight = schema.One(
    ...     schema.Integer, name="HealthInfo.weight", owner=HealthInfo,
    ...     annotates=(Person,)
    ... )

    >>> schema.itemFor(weight, nrv)
    <Attribute... HealthInfo.weight ...>

    >>> sorted(a.itsName for a in Person.getKind(nrv).attributes)  # doctest: +NORMALIZE_WHITESPACE
    ['HealthInfo.weight', 'age', 'children', 'fullname', 'parents']


