<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>Chandler 0.6 Architecture</title>


</head>


<body>

<h1>Chandler Architecture (0.6 Release)</h1>

<h3>Introduction</h3>

<p>This document gives a brief overview of Chandler's
architecture.&nbsp;We'll&nbsp;describe Chandler's
layers,
introduce Chandler-specific terminology, and give high
level&nbsp;overviews of important aspects of the architecture. </p>

<p>
Chandler is a work in progress; we are still working out both bugs in
the code that don't conform to the architecture, as well as design
issues with the architecture itself. This document describes Chandler
as of the 0.6 release.</p>

<a href="#Data_Driven_Architecture">
Data Driven Architecture</a><br>

<a href="#Layers">Layers</a><br>

<div style="margin-left: 40px;"><a href="#Application_Layer">Application</a><br>

<a href="#CPIA">Presentation (CPIA)</a><br>

<a href="#Services">Services</a><br>

<a href="#Domain_Model">Domain Model</a><br>

<a href="#Parcel_Framework">Parcel Framework</a><br>

<a href="#Repository">Repository</a></div>

<a href="#Extension_Parcels">Extension Parcels</a><br>

<a href="#Threading_Model">Threading Model</a><br>

<a href="overview.html#Collections_and_Notifications">Collections
and
Notifications</a><br>

<a href="overview.html#Internationalization">Internationalization</a><br>

<a href="overview.html#Security">Security</a><br>

<h2><a name="Data_Driven_Architecture"></a>Data
Driven Architecture</h2>

<p>Before we start describing Chandler's layers, we need to
introduce some concepts and terminology: <span style="font-weight: bold;">Items</span>,
<span style="font-weight: bold;">Kinds</span>, <span style="font-weight: bold;">Attributes</span>,&nbsp;<span style="font-weight: bold;">Collections</span>, the <span style="font-weight: bold;">Repository</span> and <span style="font-weight: bold;">Parcels</span>. These
concepts are a consequence of Chandler's data driven architecture, and
pervade the system.</p>

<p>The fundamental unit in Chandler is an&nbsp;<span style="font-weight: bold;">Item</span>. An Item is a
Python object that persists to Chandler's <span style="font-weight: bold;">Repository</span>. Each
Item object belongs to a Python class. The class that defines an Item
is known as its <span style="font-weight: bold;">Kind</span>,
and has some additional features beyond a regular Python class. In
particular, a Kind class describes the <span style="font-weight: bold;">Attributes</span> of its
items, and persists this information to the Repository.
</p>

<p>
As an example, the user may create an event on her calendar: "Lunch
with Mitch at 12pm".&nbsp; The client
code that creates a new instance of a calendar event uses the
constructor of the <span style="font-family: monospace;">CalendarEvent</span> Python class. The event instance will be stored in the
Repository
as an Item. The Item's Kind is <span style="font-family: monospace;">CalendarEvent</span>,
and thus has the Attributes&nbsp;<span style="font-family: monospace;">startTime</span> and <span style="font-family: monospace;">summary</span>. The
Item object's <span style="font-family: monospace;">summary</span>
attribute will have a value of <span style="font-family: monospace;">"Lunch
with Mitch"</span>, and <span style="font-family: monospace;">startTime</span>
will have a value of <span style="font-family: monospace;">"12pm"</span>.&nbsp;</p>

<p>
Much work in Chandler is done by creating Item objects and setting
their attributes.&nbsp;Examples of Items include calendar
events, email messages and tasks -- what we might think of as user
data.&nbsp;UI objects like menus and views are also stored as
Items,
as are services like the background task that fetches email. Under the
hood, the Kinds that describe these Items
(e.g.&nbsp;MailMessage,&nbsp;Menu, PeriodicTask) are also
persisted to
the Repository
as Items.</p>
<p>
A&nbsp;<span style="font-weight: bold;">Collection</span>is a set
of
Items, and is itself an Item. A Collection can define its
Items in several ways: by explicitly listing the items; by containing
all Items of a given Kind; by filtering another Collection using a
Python expression; or by combining two Collections with set operations.
Collections play a key role in Chandler's
architecture, discussed in more detail below in <a href="#Collections_and_Notifications">Collections and
Notifications</a>.</p>


<p>
In Chandler, Item objects and Kind classes are
defined in <span style="font-weight: bold;">Parcels</span>.
Parcels are a persistent representation of Python&nbsp;modules.
These Python modules are introspected at
startup so that Item and Kind data can be loaded into the Repository.
Most Chandler code lives in Parcels. The few exceptions to this are the
subsystems needed to bootstrap the system -- the repository itself,
wxPython related startup code, and some services used by the repository
(e.g. internationalization code).</p>

<p>
When we say that Chandler has a data driven architecture, we mean that
the application is described by Item objects that are stored in the
repository. The application can be customized and extended quite a bit
just by changing this data. Similarly, some customizations and
extensions can be shared by sharing data (someday, not in 0.6). Another
aspect of this architecture is that when an Item of a particular Kind
is displayed in the user interface, the application will automatically
pull up the appropriate code to view or manipulate the Item, based on
its Kind.</p>

<h2><a name="Layers"></a>Layers</h2>

<p>We will now look at each of the layers that make up the
Chandler
architecture. &nbsp;</p>

<img style="width: 500px; height: 724px;" alt="architecture layers" src="overview-layers.png">
<p>Generally, each layer or component is able to directly access
the
APIs of the layers below it. The lower level layers communicate to the
layers above via a system of notifications. The lower level layers
should have no specific knowledge of the layers above, and the higher
level layers should know only the APIs of the layers below.</p>

<p>
Chandler uses a variant of a Model -View - Controller architecture.
Like
many applications built on GUI frameworks, Chandler tends to mix the
View and Controller code in one layer. We expect to reexamine this
choice in
the 0.7 time frame -- this document will focus on the code as it exists
in the 0.6 release.
</p>

<h3><a name="Application_Layer"></a>Application
Layer</h3>

<p>At the top of the diagram, the application layer is
responsible for
pulling
all of the pieces together to present the interface to the user. It has
the role of a Controller in terms of an MVC architecture.</p>

<p>
The application layer handles the startup of Chandler. It contains the
main "application" class that is primarily responsible for
initializing Chandler components, as well as creating the <span style="font-weight: bold;">MainView</span> object that
describes the layout of the application.</p>

<p>
The Chandler application is built on wxPython, a cross platform GUI
toolkit. wxPython is a Python wrapper on top of <a href="http://www.wxwidgets.org/">wxWidgets</a>.
wxWidgets provides a uniform C++ API on top of native toolkits: GTK,
Win32 and OSX (Carbon).</p>

<p>
The launching point for a wxPython application is a singleton subclass
of wxApp. This subclass drives most of the startup activities by
defining an <span style="font-family: monospace;">OnInit</span>
method that gets called by wxPython at startup. In Chandler, <span style="font-family: monospace;">OnInit</span> looks for any new Parcels, loading them into the
Repository. It also kicks off Twisted, which manages the networking
services. (See&nbsp;<a href="#Services">Services</a>
and&nbsp;<a href="#Threading_Model">Threading Model</a>).
</p>

<p>
The MainView object gets populated with UI Item objects defined
in lower layers: what the menus are, where the sidebar goes, how much
space the detail view takes, etc. It also creates well
known Collection objects (e.g. "Trash", "All my Items"). It defines
event handlers for
application-wide events (e.g. "Quit", "New Collection").&nbsp;</p>

<h5>
Most application layer code can be found here (starting from the top of
the chandler directory):</h5>

<ul>

  <li style="font-weight: bold;"><span style="font-weight: normal;"><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/application/">application</a>&nbsp;The
main class that runs the wxPython application, including application
startup
code. Also includes wxPython related printing support, and some system
wide global variables.</span></li>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/application/dialogs/">application/dialogs</a>
wxPython dialogs used by the application. Eventually these may get
moved into CPIA, but currently don't fully conform to the architecture.</li>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/views/main/">parcels/osaf/views/main</a>
The definition of the MainView, the highest level block that describes
the layout of the application. Also contains most of the applications
menus, events, and event handlers.</li>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/app/">parcels/osaf/app</a>
Well known items, including well known collections and default account
information</li>
  <li style="font-weight: bold;"><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/"><span style="font-weight: normal;">Chandler.py</span></a>
    <span style="font-weight: normal;">The starting point
for the GUI
application, it creates the wxApp subclass and does high level
exception handling.</span></li>

  <li style="font-weight: bold;"><span style="font-weight: normal;"><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/tools/">tools/headless.py</a>
The
starting point for running Chandler as a server with no GUI.</span></li>

</ul>

<h3><a name="CPIA"></a>Presentation (CPIA)</h3>

<p>Chandler's Presentation layer is handled by the Chandler
Presentation and Interaction Architecture (CPIA). CPIA
blends the role of View and Controller in an MVC architecture. CPIA
is a Chandler specific framework, so it has API
knowledge of the Repository, Items, Collections, and Chandler's
Domain Model. </p>

<p>
CPIA's role is to provide building blocks for Chandler's user
interface, including
some generic building blocks (e.g. Menus, Status Bar) as well as more
Chandler
specific building blocks (e.g. Sidebar, Calendar View,
Detail View). Because we think of them as building blocks, the core
unit in CPIA is called a <span style="font-weight: bold;">Block</span>.</p>

<p>
Before we get into details about Blocks, we'll introduce some Chandler
terminology by discussing the basic elements of Chandler's user
interface that Blocks need to support:</p>

<br>

<img style="width: 484px; height: 352px;" alt="ui diagram" src="overview-layout.png"><br>

<br>

<p>Chandler has a familiar three pane view. The <span style="font-weight: bold;">Sidebar</span> contains a
list of Collections (e.g. "Home", "Work"), and one of them is selected.
The <span style="font-weight: bold;">Summary View</span>
displays the Items in the selected Collection, and one Item is
selected. The <span style="font-weight: bold;">Detail View</span>
displays
the selected Item. The <span style="font-weight: bold;">Application
Bar</span>
allows the user to select an application area (All, Calendar, Event,
Task). This selection is&nbsp;used to filter what Kinds of
Items are displayed and what type of Summary View is used. If
"Calendar" is selected in the Application Bar, for example, collections
of Calendar Events can
be seen in a
<span style="font-weight: bold;">Calendar Summary View</span>.
If "All" is selected in the Application Bar, collections are seen in a
more general <span style="font-weight: bold;">Table
Summary View</span>.
The application also has other common elements: <span style="font-weight: bold;">Menus</span>, a <span style="font-weight: bold;">Toolbar</span>, and a <span style="font-weight: bold;">Status Bar</span>.
&nbsp;The Sidebar, Calendar Summary View, Table Summary View,
Detail
View,&nbsp; Application Bar, Menus, Toolbar, and Status Bar are all
Blocks.</p>

<p>
The typical function of a Block object is to display an Item or
Collection to the user. A
Block also takes input from the user and writes changes to the Item
back to the Repository.&nbsp;Block objects can contain
other&nbsp;Blocks,
which you can think of as a tree of
blocks. The Main View is the complete tree of Blocks that describes the
layout of Chandler.&nbsp;The Detail View is another example of a
tree
of Blocks -- the selected Item's attributes are displayed using Blocks
contained by the Detail View.
The appropriate Detail View tree of Blocks gets hooked into the Main
View, depending on the Kind of Item selected.</p>

<p><span style="font-weight: bold;">Terminology note:</span>
We sometimes use "Block" and "View"
interchangeably. "View" comes from MVC, and "Block" is our
Chandler-specific term. Yes, this can be confusing, especially given
that "View" is also a common database term and we use "Repository View"
as the name for a connection to the
Repository.</p>

<p>
The presentation layer defines Block classes. The application layer
creates
Block objects, and populates them with data to create the application
specifics. Block objects are
Items, so they persist to the repository; Chandler stores information
about the user interface in the Repository. (Block classes also persist
to the Repository as Kinds. The hope is that storing this kind of data
in the Repository will someday enable us to build a cool UI builder,
but that is a future project).</p>
<p>A&nbsp;Block knows about its&nbsp;<span style="font-weight: bold;">contents</span>,
&nbsp;the user data displayed in the Block. The <span style="font-family: monospace;">contents</span>
Attribute&nbsp;is usually an Item or
Collection in the domain model (e.g. "All my items" collection, or
&nbsp;a "Lunch with Mitch" calendar event). &nbsp;The Block
delegates
the work of display and user-interaction to a delegate object, called a Widget. The Block
hands
the&nbsp;Item or Collection to the Widget to do the display.</p>

<img style="width: 383px; height: 341px;" alt="cpia block and widget" src="overview-cpia.png">
<p>
Block objects store information about the UI element they represent.
Blocks, like all Items, persist to the Repository. A calendar Block
object, for
example, might know about the collection of items displayed, if the calendar is in "day" or "week" mode, etc. The
actual implementation of the presentation is handled by the delegate <span style="font-weight: bold;">Widget</span>
class, a subclass of a wxPython class. (Widgets are wxPython objects,
they are not Items and they do not persist to the Repository).&nbsp;</p>

<p>
Another key concept in CPIA is that of an <span style="font-weight: bold;">Attribute Editor</span>.
Attribute editors are Python classes that handle the editing and
rendering of one Attribute of one Item. Attribute editors are used by
the DetailView or the SummaryTableView to render and edit a selected
Item's attributes. For example, if a CalendarEvent is selected in the
DetailView, a date-time attribute editor handles the editing and
rendering of the&nbsp;<span style="font-family: monospace;">startTime</span>,
and a text attribute editor handles the
editing and rendering of the&nbsp;<span style="font-family: monospace;">summary</span>.
Attribute editors make use
of wxPython widgets to help out with the rendering and editing.</p>

<p>
We've also been experimenting with the ability to script the
application, which we call <span style="font-weight: bold;">CPIA
Script</span>.
In 0.6 we've been focused on using scripting to automate functional
tests, but we hope to extend it to allow adventurous users to customize
their environment with scripts and potentially share scripts. Yes, we
realize that there are security implications, and hope to tackle that
issue in 0.7.</p>

<p><span style="font-weight: bold;">
Key decision:</span> CPIA is not
meant to be a general cross
platform
application building framework (such as XUL or wxWidgets).
&nbsp;We're
not trying to boil the ocean here. Chandler specific concepts like
Items, Collections,&nbsp;Sidebar, Summary View and Detail View
and their relationship to each other are embedded in the CPIA
framework. OSAF doesn't intend to use CPIA for any&nbsp;purpose other
than building the Chandler user-interface and allowing extensions to
the Chandler user-interface. See <a href="#Extension_Parcels">Extension Parcels</a> below for more information about extending Chandler. </p>

<h5>Most CPIA code can be found here:</h5>

<ul>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/framework/blocks/">parcels/osaf/framework/blocks</a>
General block and widget definitions, including base classes and the&nbsp;Table block</li>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/framework/blocks/calendar/">parcels/osaf/framework/blocks/calendar</a>
Calendar blocks and widgets</li>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/framework/blocks/detail/">parcels/osaf/framework/blocks/detail</a>
Detail view block and widget</li>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/framework/attributeEditors/">parcels/osaf/framework/attributeEditors</a>
Attribute editor infrastructure and attribute editors</li>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/framework/">parcels/osaf/framework/scripting.py</a>
Scripting framework</li>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/framework/types/">parcels/osaf/framework/types</a>
CPIA defined repository types (e.g. color)</li>

</ul>

<h3><a name="Services"></a>Services</h3>

<p>
The services layer allows Chandler to talk to the
outside world. Currently this includes sharing (via WebDAV and <a href="http://ietf.webdav.org/caldav/home.html">CalDAV</a>),
email (IMAP, POP and SMTP), and running Chandler as a local
webserver.</p>

<p>Chandler allows users to&nbsp;share Collections by
publishing them to a server. Similarly, a Chandler user can subscribe
to
other users' Collections. Even in 0.6, Chandler supports both read-only
and read-write access to these shared Collections. Import and export of
calendar data is also supported. </p>

<p>Sharing functionality is implemented with a flexible framework:</p>

<img style="width: 482px; height: 158px;" alt="sharing framework" src="SharingFramework.gif"><br>

<p>To share a Collection, the framework creates three objects: a <span style="font-weight: bold;">Share</span>, a <span style="font-weight: bold;">Format</span>, and a <span style="font-weight: bold;">Conduit</span>.
The Share object keeps track of the Collection being shared, filtering
some Items before sharing. The Format object handles the serialization
and
deserialization of Items. There are currently two Format
implementations:
iCalendar (the standard used by CalDAV), and a Chandler
specific XML format called CloudXML.
The Conduit object is responsible for&nbsp;moving serialized
representations in
and out of Chandler. Current Conduit
implementations include a
FileSystem conduit (supporting import/export), a WebDAV conduit, a
CalDAV conduit, and a simple HTTP conduit. More information about
sharing, including the 0.6 spec, can be
found at the <span style="text-decoration: underline;">sharing
project page</span>.
The sharing framework can be extended to add new Conduits and Formats;
we have <span style="text-decoration: underline;">a
tutorial on how to extend sharing</span>.</p>

<p>
Chandler's sharing code makes use of a library called <a href="http://wiki.osafoundation.org/bin/view/Projects/ZanshinProject">Zanshin</a>,
which supports collaboration over HTTP, WebDAV and CalDAV. Zanshin is
an OSAF project with no dependencies on the rest of Chandler.</p>

<p>
Zanshin and Chandler use <a href="http://twistedmatrix.com/">Twisted</a>
for networking support. Services like mail and sharing run in the
Twisted Reactor. See&nbsp;<a href="overview.html#Threading_Model">Threading
Model</a>
below for more information on how this works.&nbsp;More information
on
Twisted in Chandler can be found at <span style="text-decoration: underline;">the project page for
Twisted in Chandler</span>
and in the documentation about <span style="text-decoration: underline;">startup and background
tasks in Chandler</span>.</p>

<p>The Twisted framework enabled us to add the
experimental feature that Chandler can be run as a webserver. While we
have no current plans to use this capability for 1.0 Chandler features,
we'll continue to experiment with it as a mechanism to extend Chandler.</p>

<h5>
Most services code can be found here:</h5>

<ul style="font-weight: bold;">

  <li><span style="font-weight: normal;"><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/sharing/">parcels/osaf/sharing</a>
Sharing
services, including CalDAV and WebDAV sharing</span></li>

  <li><span style="font-weight: normal;"><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/mail/">parcels/osaf/mail</a>
Mail
services, including IMAP, POP and SMTP</span></li>

  <li><span style="font-weight: normal;"><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/">parcels/osaf/webserver.py</a>
Code to run Chandler as
a&nbsp;webserver&nbsp;</span></li>

</ul>

<h3><a name="Domain_Model"></a>Domain Model</h3>

<p>
The domain model defines all of the domain specific classes that
represent application content such as Calendar Events, Mail Messages,
Tasks, etc. It plays the role of the Model in an MVC architecture. This
means that the domain model has no knowledge of the layers
above it, allowing it to be used effectively by different Views and
Controllers.</p>

<p>
The domain model layer primarily consists of Python class
definitions for these domain specific Kinds: calendar events, mail
messages, tasks and contacts. Each of these classes is a subclass
of&nbsp;<span style="font-weight: bold;">ContentItem</span>.
The ContentItem class is a base class for all Items that
the user would typically
think of as their personal data. This layer also includes the code for
Collections and
notifications to the layers above. See&nbsp;<a href="#Collections_and_Notifications">Collections and
Notifications</a>
for more
information.</p>

<p>
As 0.6 is a calendar release, much of the domain model work went into
recurrences and timezones. You can read about this in
more detail:</p>

<ul>

  <li><a href="http://svn.osafoundation.org/docs/trunk/docs/specs/rel0_6/Timezone-0.6.html">0.6
Timezone specification</a></li>

  <li><a href="http://svn.osafoundation.org/docs/trunk/docs/specs/rel0_6/Reccurence-0.6.html">0.6
Recurrence specification</a></li>

</ul>

<p><span style="font-weight: bold;">
Terminology note</span>: We have called this layer the
"content model" in the past, so
you'll find that term in the code. We chose "Domain Model" for this
document because that term is more consistently used for this type of
layer in other projects. We're still wrestling with the terminology and
hope to clarify this further in 0.7.</p>

<h5>
Most domain model code can be found here:</h5>

<ul>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/pim/">parcels/osaf/pim</a>
Defines
the obvious personal information management (PIM) related Kind classes
(e.g. CalendarEvent, MailMessage,
Task). Also contains more general Kind classes (e.g. Collection,
ContentItem).</li>

</ul>

<h3><a name="Parcel_Framework">Parcel Framework</a></h3>

<p>
The parcel framework provides basic services for parcels; an API
to create Item objects and Kind classes, access to the threading
services of the Twisted framework, and hooks for parcels to run code at
startup.</p>


<p>
The <span style="font-weight: bold;">schema</span>
module provides the API for Chandler's data model, including an API for creating Item objects and Kind classes. Kind
classes are created by subclassing <span style="font-family: monospace;">schema.Item</span>.
Attributes are added to Kinds by defining <span style="font-weight: bold;">attribute descriptors</span>
in the Python class, which are much like Python property definitions.
Item objects can be created by calling the class constructors. The
schema module also provides an API for updating or creating well known
Item objects.&nbsp;</p>
<p>Chandler's data model has some interesting features, including <span style="font-weight: bold;">bidirectional references</span> between Items, and a mechanism for extending existing Kinds called <span style="font-weight: bold;">annotations</span>.&nbsp;<a href="parcel-schema-guide.html">The Parcel
Developer's Guide to the Schema API</a> explains these features in more detail, and provides an excellent
tour through the schema API. </p>

<p>
Parcels are both a mechanism for persisting Item objects and Kind
classes to the Repository at startup, as well as a packaging mechanism
for components in Chandler. For example, extensions to Chandler are
packaged up as
Parcels. We created Parcels before the existence of <a href="http://peak.telecommunity.com/DevCenter/PythonEggs">Python
Eggs</a>. In future releases we plan to
replace Parcels with Eggs as a unit of component packaging.</p>

<p>
The <span style="font-weight: bold;">startup</span>
module provides
hooks&nbsp;for running code at application startup. It provides
classes
that help run code in a separate thread, classes that run in the
Twisted reactor (<span style="font-weight: bold;">TwistedTask</span>),
and classes that run at periodic intervals in the Twisted reactor (<span style="font-weight: bold;">PeriodicTask</span>). More
about the <a href="#Threading_Model">threading model</a>
below. You can also read documenation about <span style="text-decoration: underline;">the startup module</span>.</p>

<h5>
Schema layer code can be found here:</h5>

<ul>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/application/">application/schema.py</a>
API for defining Chandler parcels and schema</li>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/application/">application/Parcel.py</a>
Controller code that loads parcels into the Repository.<span style="font-weight: bold;"> </span></li>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/">parcels/osaf/startup.py</a><span style="font-weight: bold;"> </span>Hooks for running
code at startup, including
TwistedTask and PeriodicTask<span style="font-weight: bold;">
    </span></li>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/framework/twisted/">parcels/osaf/framework/twisted</a>
    <span style="font-weight: normal;">Chandler specific
utilities wrapping twisted services</span></li>

</ul>

<h3><a name="Repository"></a>Repository</h3>

<p>
The Repository is the persistent store for Chandler's data driven
architecture. It implements the core code for Items and sets of Items
(the basis of Collections),
as well as notifications. It also supports full text search, sorting
and indexing of sets of Items.</p>

<p>
The Repository is essentially a Python object cache sitting on top
of <a href="http://www.sleepycat.com/">BerkeleyDB</a>.
It uses <a href="http://lucene.apache.org/">Lucene</a>
as the full text search engine. <a href="http://pylucene.osafoundation.org/">PyLucene</a>
is an OSAF project to make Lucene available to Python applications. For
more information on the creative acrobatics used to get this to work,
look at the <span style="text-decoration: underline;">PyLucene
README</span>.</p>

<p>
Client code accesses the Repository through a <span style="font-weight: bold;">RepositoryView</span>
object, which is a connection to the Repository. Client code creates,
retrieves and updates Items in the repository view, which has an object
cache local to the view. The client code can then <span style="font-weight: bold;">commit</span> the modified
Items back to the core Repository, or <span style="font-weight: bold;">refresh</span>
changes from the core Repository back into the view. The client code
can also roll back changes. The transactional model is similar to that
of <a href="http://www.nongnu.org/cvs/">CVS</a> or <a href="http://subversion.tigris.org/">Subversion</a>.
No locking is required, changes are either successfully
merged or result in a conflict error during commit or refresh. The hope
is that conflicts will be rare if we write the merging code well, and
that the application will be able to present certain conflicts to the
user and let the user make decisions about how to resolve them. (We
have no such user interface in 0.6, we resolve conflicts at higher
layers without involving the user).</p>

<p>
As the lowest layer on the Chandler stack, the Repository has no
knowledge of the layers above it. The Repository communicates with the
layers above it by providing mechanisms for tracking changes in the
Repository.<br>

</p>

<p>The Repository provides various mechanisms for tracking
changes to a given thread's Repository View, and a different&nbsp;mechanism for tracking changes in other Repository Views. <span style="font-weight: bold;">Monitors
</span>and<span style="font-weight: bold;"> watchers</span>
allow client code to track changes to Attributes (monitors track all
instances of one type of Attribute; watchers track one instance of a
particular Attribute). The Repository View also provides a method that
allows client code to poll for all recent changes in a
RepositoryView.&nbsp;To get notifications about changes that occur
in other
Repository Views, clients can register a callback that gets invoked
when the Repository View refreshes changes from the core Repository<span style="font-family: monospace;"></span>.
The callback will be given a list of all changes that happened in other
Repository Views.
</p>

<p>For the most part, the application, presentation, and services
layers
do not need to interact with these mechanisms directly. Collections use
these mechanisms to track changes, and provide a simpler API to the
layers above for noticing changes.&nbsp;<a href="#Collections_and_Notifications">Collections
and Notifications</a> are discussed below.</p>

<p>
The Repository contains the core implementations for Items, Kinds, and
Attributes. Layers above the repository use the schema API instead of
using the Repository's API directly (with some exceptions, like the
RepositoryView).</p>

<h5>Repository layer code can be found here:</h5>

<ul>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/repository/">repository</a>
  </li>

</ul>

<h2><a name="Extension_Parcels"></a>Extension
Parcels</h2>

<p>
Developers can extend Chandler by writing their own parcels. These
extension
parcels look similar to Chandler core parcels --
definitions of Item objects and Kind classes that belong in any
of the four extensible layers: Application, Presentation, Services or
Domain Model.</p>

<img style="width: 473px; height: 303px;" alt="parcel layers" src="overview-parcel.png"><br>

<p>
An extension that integrates <a href="http://www.flickr.com/">Flickr</a>
photo data into Chandler might create
Items and classes in all four layers.</p>

<ul>

  <li>Application layer:
    <ul>

      <li>menu item object to create a new photo or photo
collection</li>

      <li>menu item object to download or upload photos to Flickr</li>

      <li>event handlers to implement menu items, including
inserting a new photo collection into the sidebar</li>

      <li>populate Block objects to customize
a
detail view</li>

    </ul>

  </li>

  <li>Presentation (CPIA) layer:
    <ul>

      <li>custom thumbnail summary view Block and Widget</li>

      <li>custom
AttributeEditor for photo images</li>

    </ul>

  </li>

  <li>Domain Model:&nbsp;
    <ul>

      <li>new <span style="font-family: monospace;">photo</span>
Kind class, with an <span style="font-family: monospace;">image</span>
Attribute and a <span style="font-family: monospace;">tag</span>
Attribute</li>

    </ul>

  </li>

  <li>Services layer:&nbsp;
    <ul>

      <li>PeriodicTasks to automatically connect to Flickr and
download photos into the repository</li>

    </ul>

  </li>

</ul>

<p>
An extension parcel might separate its code into Python modules
based on these layers, or might include them all in one module if the
parcel is small enough -- it is up to the parcel
developer.</p>

<p>
The parcel framework will introspect the extension parcel and commit
the Items and Kinds to the Repository. The application will discover
the Items and Kinds, inserting the menus into the Menu Bar and
launching PeriodicTasks. When a Photo item is viewed, the application
will use the appropriate Detail View Block object and image Attribute
Editor to display the selected photo.</p>

<p>
We have a few examples of extension parcels (including a Flickr
parcel). We don't yet have any examples of custom summary views, or
quite have the infrastructure to support this well in 0.6.
We&nbsp;hope
to support a wider array of extension points in future releases. We
have several other problems to solve as well, including dependencies
between parcels and digitally signed parcels. As mentioned above, we
plan on using <a href="http://peak.telecommunity.com/DevCenter/PythonEggs">PythonEggs</a>
to address some of these problems in a more standard Pythonic way.</p>

<p>We have a detailed <span style="text-decoration: underline;">tutorial explaining the
feeds parcel</span> (a simple RSS reader). It
should be noted again that most of Chandler is written as Parcels, so
understanding how to extend Chandler is a good path to understanding
Chandler's internals.</p>

<h5>
Sample extension parcels can be found here:</h5>

<ul style="font-weight: bold;">

  <li><span style="font-weight: normal;"><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/flickr/">parcels/flickr</a>
Creates
a collection of Flickr photos in the sidebar.</span></li>

  <li><span style="font-weight: normal;"><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/amazon/">parcels/amazon</a>
Fetches
an Amazon wish list into the repository.</span></li>

  <li><span style="font-weight: normal;"><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/feeds/">parcels/feeds</a>
Sample
RSS reader, which is documented in the&nbsp;tutorial.</span></li>

  <li style="font-weight: normal;"><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/photos/">parcels/photos</a>
Extends Chandler with photos.</li>
  <li style="font-weight: normal;"><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/views/repositoryviewer/">parcels/osaf/views/repositoryviewer</a> Experimental parcel to view all Items in the Repository, accessible
from the test menu.</li>
  <li style="font-weight: bold;"><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/views/demo/"><span style="font-weight: normal;">parcels/osaf/views/demo</span></a>,&nbsp;<span style="font-weight: normal;"><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/views/cpiatest/">parcels/osaf/views/cpiatest</a>
Test code that
exercises CPIA.</span></li>

</ul>

<h2><a name="Threading_Model"></a>Threading
Model</h2>

<p>In Chandler, the Repository is the primary means that threads
use to
communicate with each other. A thread using the Repository has its own <strong style="font-weight: normal;">RepositoryView</strong>,
which is an independent connection to the
Repository.&nbsp;</p>

<p>The UI has its own thread (wxPython, like most GUI
frameworks, runs
in a single thread.) &nbsp;We're currently using the Twisted
Reactor to schedule work that needs to happen outside the UI thread.
The Reactor runs in a separate thread, and is used to schedule work:
TwistedTasks or PeriodicTasks. TwistedTasks and
PeriodicTasks&nbsp;are
Items that persist in the Repository. Each TwistedTask or PeriodicTask
has its own
<strong style="font-weight: normal;">RepositoryView</strong>,
as does the main wxPython UI thread.&nbsp;</p>

<p>To follow an example, the
PeriodicTask that fetches email creates new email Items in its
RepositoryView. After it creates the items, it calls <strong style="font-weight: normal; font-family: monospace;">commit()</strong>
on the RepositoryView, which pushes the Items to the Repository. The
UI thread calls <strong style="font-weight: normal; font-family: monospace;">refresh()</strong>
on its
RepositoryView during its OnIdle cycle, picking up the new changes. As
the new changes are picked up, the appropriate Widgets are dirtied so
that they will repaint themselves in the next Paint cycle.</p>

<h2><a name="Collections_and_Notifications"></a>Collections
and Notifications</h2>

<p>Collections are a core element of Chandler's architecture.
Collections are the primary mechanism for the application to access
Items from the Repository. Collections are also the primary mechanism
for distributing change notifications from the Repository to the layers
above.</p>

<p>We have two kinds of Collections: "basis collections" and
"virtual collections". <span style="font-weight: bold;">List
Collection</span> and <span style="font-weight: bold;">Kind
Collection</span>
are both basis collections. A List Collection is an explicit list of
Items. A Kind Collection automatically tracks all Items of a particular
Kind, even when Items are created or change Kinds.&nbsp;Virtual
collections are created by combining basis collections&nbsp;and
other
virtual collections. There are four virtual collections: <span style="font-weight: bold;">Union Collection</span>, <span style="font-weight: bold;">Intersection Collection</span>,
<span style="font-weight: bold;">Difference Collection</span>
and <span style="font-weight: bold;">Filter Collection</span>.
Union, Intersection and Difference collections combine two collections
with the obvious operation. Filter Collections start with another
collection, and then remove Items according to some condition. The
condition is a piece of Python code that evaluates to True or False.</p>

<p>The application&nbsp;maintains Collections of Content
Items (events,
tasks, mail messages, etc) to display in the Sidebar. The Sidebar uses
some combination of the above elements to build "Home Calendar" or "All
My Shared Items". The application also uses Collections to access other
types of Items: all Attribute Editors, all active Periodic Tasks,
etc.&nbsp;</p>

<p>Collections notice when Items in them have changed, or when
Items
leave or enter a Collection. Items in higher level layers can subscribe
to Collection notifications, by registering themselves with the
Collection and implementing a well known method (<span style="font-family: monospace;">onCollectionEvent)</span>.&nbsp;Collections
propagate the notifications to the list of subscribers, which
use the information to update the display, fire off a reminder, etc.</p>

<p>To notice changes that happened in other threads, the
application needs to refresh
the Repository View on the GUI thread and look for changes. This
happens regularly during the application's idle cycle. The main
application object<span style="font-family: monospace;"> </span>updates the GUI thread's Repository View<span style="font-family: monospace;"></span>,
and then delivers the collected change notifications (from the GUI
thread as well as from other threads) to subscribers. UI elements
(Blocks) are common subscribers; they can update their display when they notice their content has changed. </p>

<p>Attribute Editors are an exception to this mechanism in 0.6 --
they subscribe directly to the Repository's attribute monitors. Every
time an attribute is changed, the repository fires off a monitor to all
subscribers (in this case the Attribute Editor). We plan on
implementing notifications for a single Item in 0.7, using a mechanism similar to the one used by
Collection notifications.
Attribute Editors will use Item notifications instead of the lower
level monitors.</p>

<p><span style="font-weight: bold;">Terminology note:</span>
We
used&nbsp;to use the term "Item Collections" instead of
"Collections",
so you may see that term in specs and on the wiki.</p>

<p>For more&nbsp;detailed information on Collections and
notifications, see <a href="http://svn.osafoundation.org/docs/trunk/docs/specs/rel0_6/ItemCollection-0.6.html">the
0.6 Collections spec</a>.</p>

<h2><a name="Internationalization"></a>Internationalization
(i18n)</h2>

<p>
The 1.0 version of Chandler will contain infrastructure support for
Internationalization (hereafter referred to as i18n). This includes the
ability to localize the GUI strings (menus, tooltips, status, text
labels); media types (images, icons, html); visual style information
(fonts, colors); help (menus and tutorials); and example content
(welcome message). It also
includes locale specific support for date and time presentation,
sorting and searching, as well as calendar and timezones. We've made
significant progress towards this infrastructure in 0.6. </p>

<p>
One key decision was to build on <a href="http://www-306.ibm.com/software/globalization/icu/index.jsp">ICU</a>,
an open source i18n library available in C/C++. ICU provides services
like datetime formatting and parsing, language sensitive collation and
searching, etc. It also contains a large set of locale data. To make
use of ICU in Chandler, we've started a project to wrap ICU in Python,
called <a href="http://pyicu.osafoundation.org/">PyICU</a>.
PyICU is shipped as part of the Chandler distribution.</p>

<p>
We're now ready to try out some test localizations; we hope to have
localizations for French and/or Spanish in the next release. You can
get more
information about this from&nbsp;the <span style="text-decoration: underline;">i18n infrastructure plan</span>;
the <span style="text-decoration: underline;">i18n
project page</span> contains information about helping out with
localizations can be found; there is also a <a href="http://wiki.osafoundation.org/bin/view/Projects/ChandlerInternationalizationBusyDevelopersGuide">parcel
developer's guide to write i18n friendly code</a>.</p>

<h5>i18n services can be found here:</h5>

<ul>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/i18n/">i18n</a></li>

</ul>

<h2><a name="Security"></a>Security</h2>

<p>
Our goal is to make Chandler as secure and safe to use as possible. But
like the rest of Chandler, <a href="http://wiki.osafoundation.org/bin/view/Projects/SecurityFramework">security
work</a> is still far from a finished product. Some
things do work fairly well, some things we haven't checked, and some
things we haven't started work on yet. </p>

<p>
Chandler should be reasonably secure on a single user system, or when
each user has a separate installation on a multiuser system. We haven't
spent any time considering other cases yet. </p>

<p>
Chandler is facing the outside world mainly through the sharing and
email interfaces, and also some example parcels like Feeds (RSS
reader), Flickr
and
Amazon wish list. The email feature leverages Twisted for most of the
functionality and is expected to be reasonably secure. Although sharing
also uses Twisted, there is more Chandler-specific code that has
undergone less scrutiny. Most of the other parcels mentioned also build
on some
3rd party module which is used in other projects as well, thereby
reducing the likelihood that there are security issues. All of the
cases
(besides email) face same kind of issues as web browsers, and we have
tried to
avoid at least some of the common issues. These areas still need
further
security audits. </p>

<p>
Chandler has pretty good <a href="http://svn.osafoundation.org/docs/trunk/docs/specs/rel0_6/SSLandTLS-0.6.html">SSL
and TLS</a> support. Email and sharing can use
SSL, and for the Cosmo sharing server SSL is enabled by default.
The underlying operations are provided by <a href="http://www.openssl.org/">OpenSSL</a>, through
the <a href="http://sandbox.rulemaker.net/ngps/m2/">M2Crypto</a>
wrapper.&nbsp;</p>

<p>
It is possible to import certificates from the file system into the
<a href="http://svn.osafoundation.org/docs/trunk/docs/specs/rel0_6/CertificateStore-0.6.html">certificate
store</a>. Management of the certificate store is through a very
primitive UI available from the Test menu. Chandler ships with the same
root certificates
as Firefox.<br>

</p>

<p>
Extensions to Chandler (both&nbsp;CPIA scripts and parcels) do not
run in any kind of protected sandbox. It is the user's
responsibility to decide if they trust the extension authors. Scripts
can be shared, but when a script is subscribed to it will be disabled
by default to prevent accidentally running new scripts.<br>

</p>

<h5>Code implementing the certificate store can be found here:</h5>

<ul>

  <li><a href="http://viewcvs.osafoundation.org/chandler/branches/Chandler_0.6/chandler/parcels/osaf/framework/certstore/">parcels/osaf/framework/certstore</a></li>

</ul>
<br>


<br>

</body>
</html>
