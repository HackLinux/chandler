<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>Chandler 0.6 Architecture</title>


</head>


<body>

<h1>Chandler Architecture (0.6 Release)</h1>

<h3>Introduction</h3>

This document gives a brief overview of Chandler's architecture.
&nbsp;We'll explain some fundamental concepts that underly
Chandler's data driven architecture. We'll&nbsp;describe Chandler's layers,
introduce Chandler-specific terminology, and give high
level&nbsp;overviews of important aspects of the architecture. <br>

<br>

Chandler is a work in progress; we are still working out both bugs in
the code that don't conform to the architecture, as well as "bugs" or
problems with the architecture itself. This document is an effort to
describe Chandler as it exists in the 0.6 release.<br>

<a href="#Data_Driven_Architecture"><br>

Data Driven Architecture</a><br>

<a href="#Layers">Layers</a><br>

<div style="margin-left: 40px;"><a href="#Application_Layer">Application</a><br>

<a href="#CPIA">CPIA</a><br>

<a href="#Services">Services</a><br>

<a href="#Domain_Model">Domain Model</a><br>

<a href="#Parcel_Framework">Parcel Framework</a><br>

<a href="#Repository">Repository</a></div>

<a href="#Extension_Parcels">Extension Parcels</a><br>

<a href="#Internationalization">Internationalization</a><br>

<a href="#Security">Security</a><br>

<a href="#Collections_and_Notifications">Collections and
Notifications</a><br>

<a href="#Threading_Model">Threading Model</a><br>

<a href="#Threading_Model">Discovery and Startup</a><br>

<h2><a name="Data_Driven_Architecture"></a>Data
Driven Architecture</h2>

Before we start describing Chandler's layers, we need to introduce a
few concepts: <span style="font-weight: bold;">Items</span>,
<span style="font-weight: bold;">Kinds</span>, <span style="font-weight: bold;">Attributes</span>,&nbsp;<span style="font-weight: bold;">Collections</span>, the <span style="font-weight: bold;">Repository</span> and <span style="font-weight: bold;">Parcels</span>. These
concepts are a consequence of Chandler's data driven architecture, and
pervade the system.<br>

<br>

The fundamental unit in Chandler is an&nbsp;<span style="font-weight: bold;">Item</span>. An Item is a
Python object that it can be persisted to Chandler's <span style="font-weight: bold;">Repository</span>. An Item
is defined by its <span style="font-weight: bold;">Kind</span>.
A Kind describes information about a whole class of Items, and is
implemented as a Python class. Items have <span style="font-weight: bold;">Attributes</span>, just
like Python objects.&nbsp;The Item's Kind defines these Attributes.
<br>
<br>
As an example, the user may create an event on her calendar: "Lunch
with Mitch at 12pm".&nbsp; The event will be stored in the Repository
as an Item. This type of Item has a <span style="font-family: monospace;">CalendarEvent</span> Kind class, which defines the Attributes&nbsp;<span style="font-family: monospace;">startTime</span> and <span style="font-family: monospace;">summary</span>. The Item object's <span style="font-family: monospace;">summary</span> attribute will have a value of <span style="font-family: monospace;">"Lunch with Mitch"</span>, and the <span style="font-family: monospace;">startTime</span> attribute will have a value that represents <span style="font-family: monospace;">"12pm"</span>.<span style="font-family: monospace;"></span><br>

<br>

Much work in Chandler is done by creating Item objects and setting their attributes.&nbsp;Examples of Items include calendar
events, email messages and tasks -- what we might think of as user
data.&nbsp;UI objects like menus and views are also stored as
Items,
as are services like the background task that fetches email. Under the
hood, the Kinds that describe these Items
(e.g.&nbsp;MailMessage,&nbsp;Menu, PeriodicTask) are also
persisted to
the Repository
as Items. (The Python code isn't persisted, but meta-data that
describes these Kinds is persisted).&nbsp;<br>

<br>

Most Chandler code is in the form of&nbsp;Python classes that
implement
a Kind. These Python classes define the Kind's Attributes and implement
methods associated with that Kind. Because the terminology can be
confusing, in this document we'll often say
"class" or "Python class" instead of using the term "Kind".<br>

<br>

A&nbsp;<span style="font-weight: bold;">Collection</span>
is a set of
Items, and is itself an Item. A Collection can define the set of
Items either by explicitly listing the items, with a query against the repository, or by combining
two other Collections. Collections play a key role in Chandler's
architecture, discussed in more detail below in <a href="#Collections_and_Notifications">Collections</a>.<br>

<br>

In Chandler, Item objects and Kind classes are
defined in <span style="font-weight: bold;">Parcels</span>.
Parcels are Python packages and modules that are introspected at
startup so that Item and Kind data can be loaded into the Repository.<br>

<br>

Most Chandler code lives in Parcels. The few exceptions to this are the
subsystems needed to bootstrap the system -- the repository itself,
wxPython related startup code, and some services used by the repository
(e.g. internationalization code).<br>

<br>

When we say that Chandler has a data driven architecture, we mean that
the application is described by Item objects that are stored in the
repository. The application can be customized and extended quite a bit
just by changing this data. Similarly, some customizations and
extensions can be shared by sharing data (someday, not in 0.6). Another
aspect of this architecture is that when an Item of a particular Kind
is displayed in the user interface, the application will automatically
pull up the appropriate code to view or manipulate the Item, based on
its Kind.<br>

<h2><a name="Layers"></a>Layers</h2>

We will now look at each of the layers that make up the Chandler
architecture. &nbsp;<br>

<h3><img style="width: 500px; height: 724px;" alt="architecture layers" src="overview-layers.png">
</h3>

<br>

Generally, each layer or component is able to directly access the
APIs of the layers below it. The lower level layers communicate to the
layers above via a system of notifications. The lower level layers
should have no specific knowledge of the layers above, and the higher
level layers should know only the APIs of the layers below.<br>

<br>

Chandler uses a variant of a Model -View - Controller architecture.
Like
many applications built on GUI frameworks, Chandler tends to mix the
View and Controller code in one layer. We expect to reexamine this
choice in
the 0.7 timeframe -- this document will focus on the code as it exists
in the 0.6 release.
<h3><a name="Application_Layer"></a>Application
Layer</h3>
At the top of the diagram, The application layer is responsible for pulling
all of the pieces together to present the interface to the user. It has
the role of a Controller in terms of an MVC architecture.<br>

<br>

The application layer handles the startup of Chandler. It contains the
main "application" class that is primarily responsible for
initializing Chandler components, as well as populating the <span style="font-weight: bold;">MainView</span> object that
describes the layout of the application.<br>

<br>

The Chandler application is built on wxPython, a cross platform GUI
toolkit. wxPython is a python wrapper on top of <a href="http://www.wxwidgets.org/">wxWidgets</a>.
wxWidgets provides a uniform C++ API on top of native toolkits: GTK,
Win32 and OSX (Carbon).<br>

<br>

The launching point for a wxPython application is a singleton subclass
of wxApp. This subclass drives most of the startup activities by
defining an OnInit
method that gets called by wxPython at startup. In Chandler, this
method loads all
of the Parcels and commits Items defined in the parcels to the
Repository. It also kicks off Twisted, which manages the networking
services. (See&nbsp;<a href="#Services">Services</a>
and&nbsp;<a href="#Threading_Model">Threading Model</a>).
<br>

<br>

The MainView object gets populated with UI Item objects defined
in lower layers: what the menus are, where the sidebar goes, how much
space the detail view takes, etc. It also creates well
known Collection objects (e.g. "Trash", "All my Items"). It defines
event handlers for
application-wide events (e.g. "Quit", "New Collection").&nbsp;<br>

<h5>
Most application layer code can be found here (starting from the top of the chandler directory):</h5>

<ul>
  <li style="font-weight: bold;">application<span style="font-weight: normal;">&nbsp;The
main class that runs the wxPython app, including application startup
code. Also includes wxPython related printing support, and some system
wide global variables.</span></li>
  <li><span style="font-weight: bold;">application.dialogs</span>
wxPython dialogs used by the application. Eventually these may get
moved into CPIA, but currently don't fully conform to the architecture.</li>
  <li><span style="font-weight: bold;">parcels.osaf.views.main</span>
The definition of the MainView, the highest level block that describes
the layout of the application. Also contains most of the applications
menus, events, and event handlers.</li>

  <li><span style="font-weight: bold;">parcels.osaf.app</span>
Well known items, including well known collections and default account
information</li>

  <li><span style="font-weight: bold;">parcels.osaf.app.scripts</span>
Example scripts</li>

  <li><span style="font-weight: bold;">parcels.osaf.views.repositoryviewer</span>
The repository viewer is an early "experimental" feature, accessible
from the test menu.</li>

  <li style="font-weight: bold;">parcels.osaf.views.demo,&nbsp;parcels.osaf.views.cpiatest<span style="font-weight: normal;">&nbsp;Test code that
exercises CPIA.</span></li>
  <li style="font-weight: bold;">Chandler.py <span style="font-weight: normal;">The starting point for the GUI
application, it creates the wxApp subclass and does high level exception handling.</span></li>
  <li style="font-weight: bold;"><span style="font-weight: normal;"><span style="font-weight: bold;">tools.headless</span> The
starting point for running Chandler as a server with no GUI.</span></li>

</ul>

<h3><a name="CPIA"></a>Presentation (CPIA)</h3>
Chandler's Presentation layer is handled by a framework we call CPIA.
CPIA stands for Chandler Presentation and Interaction Architecture. It
blends the role of View and Controller in an MVC architecture. CPIA
is intended to be a Chandler specific framework, so it has API
knowledge of the Repository, Items, Collections, and Chandler's
Domain Model. <br>

<br>

CPIA's role is to provide building blocks for Chandler's user
interface, including
some generic building blocks (e.g. Menus, Status Bar) as well as more
Chandler
specific building blocks (e.g. Sidebar, Calendar View,
Detail View). Because we think of them as building blocks, the core
unit in CPIA is called a <span style="font-weight: bold;">Block</span>.<br>
<br>

Before we get into details about Blocks, we'll introduce some Chandler
terminology by discussing the basic elements of Chandler's user
interface that Blocks need to support: &lt;TODO: update diagram to include Application Bar&gt;<br>

<br>

<img style="width: 484px; height: 340px;" alt="ui diagram" src="ChandlerUI.png"><br>

<br>

Chandler has a familiar three pane view. The <span style="font-weight: bold;">Sidebar</span> contains a
list of Collections, and one of them is selected. The <span style="font-weight: bold;">Summary View</span>
displays the Items in the selected Collection, and one Item is selected. The <span style="font-weight: bold;">Detail View</span> displays
the selected Item. The <span style="font-weight: bold;">Application
Bar</span>
allows the user to select an application area (All, Calendar, Event,
Task). This selection is&nbsp;used to filter what Kinds of
Items are displayed and what type of Summary View is used. If
"Calendar" is selected, for example, collections of Calendar Events can
be seen in a
<span style="font-weight: bold;">Calendar Summary View</span>. If "All" is selected, collections are seen in a more general <span style="font-weight: bold;">Table Summary View</span>. The application also has other common elements: <span style="font-weight: bold;">Menus</span>, a <span style="font-weight: bold;">Toolbar</span>, and a <span style="font-weight: bold;">Status Bar</span>.
&nbsp;The Sidebar, Calendar Summary View, Table Summary View, Detail
View,&nbsp; Application Bar, Menus, Toolbar, and Status Bar are all
Blocks.<br>

<br>
The typical function of a Block object is to pull an Item or Collection
from
the Repository and display it to the user. A
Block also takes input from the user and commits edits to the Item
back to the Repository.&nbsp;Block objects can contain
other&nbsp;Blocks,
which you can think of as a tree of
blocks. The Main View is the complete tree of Blocks that describes the
layout of Chandler.&nbsp;The Detail View is another example of a tree
of Blocks, where the contained Blocks represent elements of the Detail
View.
The appropriate Detail View tree of Blocks gets hooked into the Main
View, depending on the Kind of Item selected.<br>
<br>
<span style="font-weight: bold;">Terminology note:</span> We sometimes use "Block" and "View"
interchangably. "View" comes from MVC, and "Block" is our
Chandler-specific term. Yes, this can be confusing, especially given
that "View" is also a common database term and we use "Repository View" as the name for a connection to the
Repository.<br>

<br>

The presentation layer defines Block classes. The application layer creates
Block objects, and populates them with data to create the application
specifics. Block objects are
Items, so they persist to the repository. (Block classes also persist
to the Repository as Kinds. The hope is that storing this kind of data
in the Repository will someday enable us to build a cool UI builder,
but that is a future project).<br>

<br>

<img style="width: 383px; height: 341px;" alt="cpia block and widget" src="overview-cpia.png"><br>

<br>
A&nbsp;Block knows about its&nbsp;<span style="font-weight: bold;">contents</span>, &nbsp;the user data displayed in the Block. The <span style="font-family: monospace;">contents</span>
Attribute&nbsp;is usually an Item or
Collection in the domain model (e.g. "All my items" collection, or
&nbsp;a "Lunch with Mitch" calendar event). &nbsp;The Block delegates
the rendering work to a delegate object, called a Widget. The block
hands
the&nbsp;Item or Collection to the Widget to do the rendering. <br>
<br>
Block objects store information about the UI element they represent.
Blocks, like all Items, persist to the Repository. A calendar Block
object, for
example, might know about the collection of items displayed, the
currently selected item, and the currently selected date range. The
actual implementation of the presentation, or the "rendering" of the
Block, is handled by the delegate <span style="font-weight: bold;">Widget</span>
class, a subclass of a wxPython class. (Widgets are wxPython objects,
they are not Items and they do not persist to the Repository).&nbsp;<br>

<br>

Another key concept in CPIA is that of an <span style="font-weight: bold;">AttributeEditor</span>.
Attribute editors are Python classes that handle the editing and
rendering of one Attribute of one Item. Attribute editors are used by
the DetailView or the SummaryTableView to render and edit a selected
Item's attributes. For example, if a CalendarEvent is selected in the
DetailView, a date-time attribute editor handles the editing and
rendering of the&nbsp;<span style="font-family: monospace;">startTime</span>,
and a text attribute editor handles the
editing and rendering of the&nbsp;<span style="font-family: monospace;">summary</span>.
Attribute editors make use
of wxPython widgets to help out with the rendering and editing.<br>

<br>

We've also been experimenting with the ability to script the
application, which we call <span style="font-weight: bold;">CPIA
Script</span>.
In 0.6 we've been focused on using scripting to automate functional
tests, but we hope to extend it to allow adventurous users to customize
their environment with scripts and potentially share scripts. Yes, we
realize that there are security implications, and hope to tackle that
issue in 0.7.<br>

<br>

<span style="font-weight: bold;">
Key decision:</span> CPIA is not meant to be a general cross
platform
application building framework (ala XUL or wxWidgets). &nbsp;We're
not trying to boil the ocean here. Chandler specific concepts like
Items, Collections,&nbsp;Sidebar, Summary View and Detail View
and their relationship to each other are embedded in the CPIA
framework. <br>

<span style="font-weight: bold;">
</span>
<h5>Most CPIA code can be found here:</h5>

<ul>

  <li><span style="font-weight: bold;">parcels.osaf.framework.blocks</span>
General block and widget definitions, including base classes and the
SummaryTable block</li>

  <li><span style="font-weight: bold;">parcels.osaf.framework.blocks.calendar</span>
Calendar blocks and widgets</li>

  <li><span style="font-weight: bold;">parcels.osaf.framework.blocks.detail</span>
Detail view block and widget</li>

  <li><span style="font-weight: bold;">parcels.osaf.framework.attributeEditors</span>
Attribute editor infrastructure and attribute editors</li>

  <li><span style="font-weight: bold;">parcels.osaf.framework.scripting</span>
Scripting framework</li>

  <li><span style="font-weight: bold;">parcels.osaf.framework.types</span>
CPIA defined repository types (e.g. color)</li>

</ul>

<h3><a name="Services"></a>Services</h3>

The services layer provides services to allow Chandler to talk to the
outside world. Currently this includes sharing (via WebDAV and <a href="http://ietf.webdav.org/caldav/home.html">CalDAV</a>),
email (via IMAP and POP), and support to run Chandler as a local
webserver.<br>

<br>
The Chandler application allows users to&nbsp;share Collections by
publishing them to a server. Similarly, a Chandler can subscribe to
other users' Collections. Even in 0.6, Chandler supports both read-only
as well as read-write access to these shared calendars. Chandler also
supports import and export of
calendar data. <br>
<br>
Chandler implements this functionality with a flexible
sharing framework:<br>

<br>

<img style="width: 482px; height: 158px;" alt="sharing framework" src="SharingFramework.gif"><br>

<br>

The sharing framework shares a Collection by creating three objects: a <span style="font-weight: bold;">Share</span>, a <span style="font-weight: bold;">Format</span>, and a <span style="font-weight: bold;">Conduit</span>.
The Share
object is the coordinator, making decisions about which Items need to
be imported or exported. The Share delegates the serialization and
deserialization to the Format object. Supported Formats include the
iCalendar standard format, the CalDAV standard format, and a Chandler
specific XML format called CloudXML.
The Share delegates the task of moving serialized representations in
and out of Chandler to the Conduit object. Current Conduit
implementations include a
FileSystem conduit (supporting import/export), a WebDAV conduit, a
CalDAV conduit, and a simple HTTP conduit. More information about
sharing, including the 0.6 spec, can be
found <a href="http://wiki.osafoundation.org/bin/view/Projects/SharingProject">here</a>.
The sharing framework can be extended to add new conduits and formats,
a tutorial on how to extend sharing can be found here. &lt;TODO: insert
link to morgen's doc&gt;<br>

<br>

Chandler's sharing code makes use of a library called <a href="http://wiki.osafoundation.org/bin/view/Projects/ZanshinProject">Zanshin</a>,
which supports collaboration over HTTP, WebDAV and CalDAV. Zanshin is
an OSAF project with no dependencies on the rest of Chandler.<br>

<br>

Zanshin and Chandler use the <a href="http://twistedmatrix.com/">Twisted</a>
framework for networking support. Chandler
services like mail and sharing run in the Twisted Reactor. See&nbsp;<a href="overview.html#Threading_Model">ThreadingModel</a>
below for more information on how this works. More information on
Twisted in Chandler can be found <a href="http://wiki.osafoundation.org/bin/view/Projects/TwistedHome">here</a>
and here. &lt;TODO: insert link to startup document&gt;<br>

<h5>
Most services code can be found here:</h5>

<ul style="font-weight: bold;">

  <li>parcels.osaf.sharing <span style="font-weight: normal;">Sharing
services, including CalDAV and WebDAV sharing</span></li>

  <li>parcels.osaf.mail <span style="font-weight: normal;">Mail
services, including IMAP and POP</span></li>

  <li>parcels.osaf.webserver <span style="font-weight: normal;">Code to run Chandler as
a&nbsp;webserver&nbsp;</span></li>

</ul>

<h3><a name="Domain_Model"></a>Domain Model</h3>

The domain model layer defines all of the domain specific classes that
represent application content such as Calendar Events, Mail Messages,
Tasks, etc. It plays the role of the Model in an MVC architecture. This
means that the domain model should have no knowledge of the layers
above it, allowing it to be used equally effectively by different types
of Views and Controllers.<br>

<br>

The domain model layer primarily consists of Python class
definitions for these domain specific Kinds: calendar events, mail
messages, tasks and contacts. Each of these classes is a subclass
of&nbsp;<span style="font-weight: bold;">ContentItem</span>.
The ContentItem class is a base class for all Items that
the user would typically
think of as their personal data.<br>

<br>

This layer also includes the code for Collections and for
notifications to the layers above. See&nbsp;<a href="#Collections_and_Notifications">Collections</a>
for more
information.<br>

<br>

As 0.6 was a calendar release, much of the domain model work went into
making recurrences and timezones work. You can read about this in
more detail:<br>

<ul>

  <li><a href="http://svn.osafoundation.org/docs/trunk/docs/specs/rel0_6/Timezone-0.6.html">0.6
Timezone specification</a></li>

  <li><a href="http://svn.osafoundation.org/docs/trunk/docs/specs/rel0_6/Reccurence-0.6.html">0.6
Recurrence specification</a></li>

</ul>

<span style="font-weight: bold;">
Terminology note</span>: We've have called this layer the
"content model" in the past, so
you'll find that term in the code. I chose "Domain Model" for this
document because that term is more consistently used for this type of
layer in other projects. We're still wrestling with the terminology and
hope to clarify this further in 0.7.<br>

<h5>
Most domain model code can be found here:</h5>

<ul>

  <li><span style="font-weight: bold;">parcels.osaf.pim</span>
Defines
the obvious personal information management (PIM) related Kind classes (e.g. CalendarEvent, MailMessage,
Task). Also contains more general Kind classes (e.g. Collection,
ContentItem).</li>

</ul>

<h3><a name="Parcel_Framework">Parcel Framework</a></h3>

The parcel framework layer provides basic services for parcels; an API
to create Item objects and Kind classes, access to the threading
services of the Twisted framework, and hooks for parcels to run code at
startup.<br>
<br>
The <span style="font-weight: bold;">schema</span> module provides an API for creating Item objects and Kind classes. Kind classes are created by subclassing <span style="font-family: monospace;">schema.Item</span>. Attributes are added to Kinds by defining <span style="font-weight: bold;">attribute descriptors</span>
in the Python class, which are much like Python property definitions.
Item objects can be created by calling the class constructors. The
schema module also provides an API for updating or creating well known
Item objects.<br>

<br>
<a href="overview.html#Parcel_Framework">The Parcel Developer's Guide to the Schema API</a> provides an excellent tour through the schema api, with more detailed information. <br>
<br>
Parcels are both a mechanism for persisting Item objects and Kind
classes to the Repository at startup, as well as a packaging mechanism
for components in Chandler. Extensions to Chandler are packaged up as
Parcels, for example. We created Parcels before the existence of <a href="http://peak.telecommunity.com/DevCenter/PythonEggs">Python Eggs</a>
(or at least before we knew about them). In future releases we plan to
replace Parcels with Eggs as a unit of component packaging.<br>
<br>
The <span style="font-weight: bold;">starup</span> module provides
hooks&nbsp;for running code at application startup. It provides classes
that help run code in a separate thread, classes that run in the
Twisted reactor (<span style="font-weight: bold;">TwistedTask</span>), and classes that run at periodic intervals in the Twisted reactor (<span style="font-weight: bold;">PeriodicTask</span>). More about the <a href="#Threading_Model">threading model</a> below. More about the startup module <a href="#Parcel_Framework">here</a>.<br>

<h5>
Schema layer code can be found here:</h5>

<ul>

  <li><span style="font-weight: bold;">application.schema</span> API for defining Chandler parcels and schemas</li>
  <li><span style="font-weight: bold;">application.Parcel</span> Controller code that loads parcels into the Repository.<span style="font-weight: bold;"><br>
    </span></li>

  <li><span style="font-weight: bold;">parcels.osaf.startup </span>Hooks for running code at startup, including TwistedTask and PeriodicTask<span style="font-weight: bold;"><br>

    </span></li>

  <li><span style="font-weight: bold;">parcels.osaf.framework.twisted</span>
    <span style="font-weight: normal;">Chandler specific
utilities wrapping twisted services</span></li>

</ul>

<h3><a name="Repository"></a>Repository</h3>

The Repository is the persistent store for Chandler's data driven
architecture. It implements the core code for Items and sets of Items (the basis of Collections),
as well as notifications. It also supports full text search, sorting and indexing of sets of Items.<br>

<br>
The Repository is essentially a Python object cache sitting on top
of <a href="http://www.sleepycat.com/">BerkeleyDB</a>. It uses <a href="http://lucene.apache.org/">Lucene</a> as the full text search engine. <a href="http://pylucene.osafoundation.org/">PyLucene</a>
is an OSAF project to make Lucene available to Python applications. For
more information on the creative acrobatics used to get this to work,
look <a href="http://svn.osafoundation.org/pylucene/trunk/README">here</a>.<br>

<br>

Client code gets access to the Repository through a <span style="font-weight: bold;">RepositoryView</span>
object, which is a connection to the Repository. Client code creates,
retreives and updates Items in the repository view, which has an object
cache local to the view. The client code can then <span style="font-weight: bold;">commit</span> the modified Items back to the core Repository, or <span style="font-weight: bold;">refresh</span>
changes from the core Repository back into the view. The client code
can also roll back changes. The transactional model is similar to that
of CVS or SVN. No locking is required, changes are either successfully
merged or result in a conflict error during commit or refresh. The hope
is that conflicts will be rare if we write the merging code well, and
that the application will be able to present certain conflicts to the
user and let the user make decisions about how to resolve them. (We
have no such user interface in 0.6, we resolve conflicts at higher
layers without involving the user).<br>
<br>
The Repository contains the core implementations for Items, Kinds, and
Attributes. Layers above the repository use the schema api instead of
using the Repsitory's API directly (with some exceptions, like the
RepositoryView).<br>

<h5>Repository layer code can be found here:</h5>

<ul>

  <li><span style="font-weight: bold;">repository.*</span>
  </li>

</ul>

<h2><a name="Extension_Parcels"></a>Extension
Parcels</h2>
Developers can extend Chandler by writing their own parcels. These
extension
parcels largely look very similar to Chandler core parcels --
definitions of Item objects and Kind Python classes. Extension
parcels define Item objects and Kind classes that belong in any
of the four extensible layers: Application, Presentation, Services or
Domain Model. For example, an extension that integrates Flickr data
into Chandler
might create Items and classes in all four
layers:<br>

<br>

<img style="width: 473px; height: 303px;" alt="parcel layers" src="overview-parcel.png"><br>

An extension that integrates Flickr data into Chandler might create Items and classes in all four layers:<br>
<ul>
  <li>Application layer:</li>
  <ul>
    <li>menu item object to create a new photo or photo collection</li>
    <li>menu item object to download or upload photos to Flickr</li>
    <li>event handlers to implement menu items, including inserting a new photo collection into the sidebar</li>
    <li>populate Block objects to customize
a
detail view</li>
  </ul>
  <li>Presentation (CPIA) layer:</li>
  <ul>
    <li>custom thumbnail summary view Block and Widget</li>
    <li>custom
AttributeEditor for photo images</li>
  </ul>
  <li>Domain Model:&nbsp;</li>
  <ul>
    <li>new <span style="font-family: monospace;">photo</span> Kind class, with an <span style="font-family: monospace;">image</span> Attribute and a <span style="font-family: monospace;">tag</span> Attribute</li>
  </ul>
  <li>Services layer:&nbsp;</li>
  <ul>
    <li>PeriodicTasks to automatically connect to Flickr and download photos into the repository</li>
  </ul>
</ul>





An extension parcel might separate its code into Python modules
based on these layers, or might include them all in one module if the
parcel is small enough -- its up to the judement of the parcel
developer.<br>
<br>
The parcel framework will introspect the extension parcel and commit
the Items and Kinds to the Repository. The application will discover
the Items and Kinds, inserting the menus into the Menu Bar and
launching PeriodicTasks. When a Photo item is viewed, the application
will use the appropriate Detail View Block object and image Attribute
Editor to display the selected photo.<br>
<br>
We have a few examples of extension parcels (including a flickr
parcel). We don't yet have any examples of custom summary views, or
quite have the infrastructure to support this well in 0.6. We&nbsp;hope
to support a wider array of extension points in future releases. We
have several other problems to solve as well, including dependencies
between parcels and digitally signed parcels. As mentioned above, we
plan on using <a href="http://peak.telecommunity.com/DevCenter/PythonEggs">PythonEggs</a> to address some of these problems in a more standard Pythonic way.<br>
<br>
A detailed tutorial explaining the feeds parcel (a simple RSS reader)
can be found here. &lt;TODO: insert link to Alec's tutorial&gt;. It
should be noted again that most of Chandler is written as Parcels, so
understanding how to extend Chandler is a good path to understanding
Chandler's internals.<br>

<h5>
Sample extension parcels can be found here:</h5>

<ul style="font-weight: bold;">

  <li>parcels.flickr <span style="font-weight: normal;">Creates
a collection of Flickr photos in the sidebar.</span></li>

  <li>parcels.amazon <span style="font-weight: normal;">Fetches
an amazon wish list into the repository.</span></li>

  <li>parcels.feeds <span style="font-weight: normal;">Sample
RSS reader, which is documented in the&nbsp;tutorial.</span></li>

  <li style="font-weight: normal;"><span style="font-weight: bold;">parcels.photos</span> Extends Chandler with photos.</li>

</ul>

<h2><a name="Internationalization"></a>Internationalization
(i18n)</h2>

The 1.0 version of Chandler will contain infrastructure support for
Internationalization (hereafter referred to as i18n). This includes the
ability to localize the GUI strings (menus, tooltips, status, text
labels); media types (images, icons, html); visual style information
(fonts, colors); and example content (welcome message). It also
includes locale specific support for date and time presentation,
sorting and searching, as well as calendar and timezones. We've made
significant progress towards this infrastructure in 0.6. <br>

<br>

One key decision was to build on <a href="http://www-306.ibm.com/software/globalization/icu/index.jsp">ICU</a>,
an open source i18n library available in C/C++. ICU provides services
like datetime formatting and parsing, language sensitive collation and
searching, etc. It also contains a large set of locale data. To make
use of ICU in Chandler, we've started a project to wrap ICU in Python,
called <a href="http://pyicu.osafoundation.org/">PyICU</a>.
PyICU is shipped as part of the Chandler distribution.<br>

<br>

We're now ready to try out some test localizations; we hope to have
localizations for French and/or Spanish in the next release. More
information about the i18n infrastructure can be found <a href="http://wiki.osafoundation.org/bin/view/Projects/ChandlerInternationalizationProposal">here</a>;
information about helping out with localizations can be found <a href="http://wiki.osafoundation.org/bin/view/Projects/InternationalizationProject">here</a>.<br>

<h2><a name="Security"></a>Security</h2>

&lt;TODO: insert short summary here m2crypto? certstore? note both
scripting as glaring issue as well as future signed parcels&gt;<br>

parcels.osaf.framework.certstore
<h2><a name="Collections_and_Notifications"></a>Collections
and Notifications</h2>

&lt;TODO: insert wise and clarifying discussion of collections and
notifications here&gt;
<h2><a name="Threading_Model"></a>Threading
Model</h2>

<p>In Chandler, the Repository is the primary means that threads
use to
communicate with each other. A thread using the Repository has its own <strong>RepositoryView</strong>,
which is an independent connection to the
Repository.&nbsp;</p>

<p>The UI has its own thread (wxWidgets, like most GUI frameworks, runs
in a single thread.) &nbsp;We're currently using the Twisted
Reactor to schedule work that needs to happen outside the UI thread.
The Reactor runs in a separate thread, and is used to schedule work. In
Chandler the units of work are called&nbsp;<span style="font-weight: bold;">PeriodicTasks</span>, which
are Items that pesist in the Repository. Each PeriodicTask has its own <strong style="font-weight: normal;">Repository View</strong>,
as does the main wxWidgets UI thread.&nbsp;</p>

<p>To follow an example, the
PeriodicTask that fetches email creates new email Items in its
RepositoryView. After it creates the items, it calls <strong style="font-weight: normal; font-family: monospace;">commit()</strong>
on the RepositoryView, which pushes the Items to the Repository. The
UI thread calls <strong style="font-weight: normal; font-family: monospace;">refresh()</strong>
on its
RepositoryView during its OnIdle cycle, picking up the new changes. As
the new changes are picked up, the appropriate Widgets are dirtied so
that they will repaint themselves in the next Paint cycle. </p>

<h2><a name="Discovery_and_Startup"></a>Discovery</h2>

&lt;TODO: explain discovery paradigm not
registration&gt;<span style="font-weight: bold;"><br>

</span>
</body>
</html>
