<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <title>ZaoBao Tutorial</title>
  <style type="text/css">
<!--
body {
	font: Arial, Helvetica, sans-serif;
}
.code {
	background-color: #CCCCCC;
	border: 1px solid #666666;
	padding: 10px;
}
.callout {
	padding-left: 10px;
}
.fake-link {
	color: #0033FF;
}
.diagram {
	float: right;
	margin-left: 25px;
	margin-right: 25px;
}
.text-with-diagram {
	position: relative;
	clear: both;
}
p {
	text-align: justify;
}

p.ednote {
	display: block;
	font-style: italic;
}

a.meta {
	float: right;
	position: fixed;
	right: 0px;
	top: 0px;
	background: lightgrey;
	border: 2px outset lightgrey;
	padding: 5px;
	text-decoration: none;
	z-index: 1;
}
-->
  </style>
</head>
<body>
<script language="javascript">

function findRule(rules, selectorText) {
  for (i in rules) {
      if (rules[i].selectorText == selectorText)
	      return rules[i];
  } 
}

function toggleEdNotes()
{
  if (!document.styleSheets) return;
  
  var theRules;
  
  var styleSheet = document.styleSheets[0]
  if (styleSheet.cssRules)
    theRules = styleSheet.cssRules;
  else if (styleSheet.rules)
    theRules = styleSheet.rules;
  else
    return;
  /* find the right rule */
  rule = findRule(theRules, "p.ednote");
  
  if (rule.style.display == 'none')
      rule.style.display = 'block';
  else 
      rule.style.display = 'none';
}
</script>
<a class="meta" href="#" onclick="toggleEdNotes(); return false">Toggle Editor Notes</a>
<h1>Chandler Extension Tutorial </h1>
<p>Chandler 0.6</p>
<p class="ednote">The voicing throughout the document is a little awkward - after I get the whole thing written, I'm going to go through and clean up &quot;you&quot;, &quot;we&quot; etc...</p>
<p class="ednote">I also need to fix up the installParcel() declarations, perhaps putting them all into __init__.py for the sake of the tutorial </p>
<h2>Introduction</h2>
<p>This tutorial will step you through the creation of an extension for
Chandler. Chandler extensions are usually called 'parcels'. </p>
<h3>ZaoBao: An RSS Reader</h3>
<p>ZaoBao is an RSS reader that integrates with the existing data model
and allows the user to treat RSS data like other data in Chandler. This
means that RSS articles can be stamped as tasks, placed on the
calendar, shared with others, or sent as e-mail. This tutorial will
step you through the process of writing this extension.</p>
<h3>Getting started</h3>
<p>First download the 0.6 release of Chandler from the <a
 href="http://downloads.osafoundation.org/">Chandler Downloads Page</a>.
For normal Python development, you should only need the compressed
"End-Users's Distribution" for your platform. Using the compressed
version (such as the .zip, .tar.gz, or .dmg) will be easier to work
with than the installer version.</p>
<p>Unpack the file into a well known directory. For the purposes of
this tutorial, this file will be unpacked in ~/chandler. On Windows,
the chandler executable is in ~/chandler/chandler.exe. </p>
<p>New extensions will be installed in the <code>parcels</code>
subdirectory. The Chandler 0.6 distribution includes a finished version
of ZaoBao in parcels/feeds. Delete the feeds directory, or move it
outside of the parcels directory, so that it doesn't conflict with the
extension that you'll develop in this tutorial. </p>
<h3>Starting Chandler</h3>
<p>When developing for chandler, you'll often need to pass parameters
to chandler on startup. To make this easy, you should run chandler from
the command line. There are a few useful parameters that will be useful
while :</p>
<dl>
  <dt> </dt>
  <dt><code>-c, --create</code></dt>
  <dd>Erases all user data and user interface information and starts
with a fresh repository. Use this parameter whenever you change schema
or user interface data. </dd>
  <dt><code>-W</code></dt>
  <dd>Runs the chandler web server while chandler is running, for easy
inspection of data inside chandler. While chandler is running, you can
go to <a href="http://localhost:1888/">http://localhost:1888/</a> to
see an internal view of the Repository. </dd>
  <dt><code>-P &lt;directory&gt;</code></dt>
  <dd>Stores all user data in the given directory. Use this if you
don't want this extension development to interfere with data in an
installed version of chandler.</dd>
</dl>
<p>For example, to start chandler with a fresh repository stored in the
current directory, with the web server running, you would type:</p>
<p><code>&gt; ./chandler --create -W -P.</code></p>
<p>&nbsp;</p>
<h2>Data Description </h2>
<p class="ednote">Either in here, or somewhere soon, we need to describe the basic idea of the Repository. Here's some sample text:</p>
<p class="ednote">Chandler stores all of its data objects in the &quot;Repository&quot;. The Repository is a database used to persistently store Python objects. When an object is created &quot;in The Repository&quot; then certain attributes in the object will persist even if chandler is shut down and restarted. Any type of attribute can be stored in the Repository including complex data structures like dicts and lists, as well as reference to other objects. In all other respects, these Repository objects behave just like Python objects. </p>
<p class="ednote">Instead of storing data in structured tables like a traditional database, the Repository keeps all of its objects in a big &quot;soup&quot;. Objects can be retrieved by queries into this soup, or simply by following references from one object to another. </p>
<p>You may be curious and excited to jump write in and write some
  code. But in the world of Chandler, data is king. The sooner you define
  your data types, the more easily you can build a user interface around
  it. Don't worry, you can change your data types later, but you can't
  develop any meaningful application without at least some scaffolding. </p>
<p>The first thing to begin thinking about is the units of information
that your extension will manage. This will help develop your schema. A
schema is a description of your data and how the different data items
relate to each other. </p>
<p> Here are some questions that may help you get started: </p>
<ul>
  <li> What are the base units or items that your application will use?
  </li>
  <li> What attributes are stored on those items? </li>
  <li> Are there many objects of the same type? How are they grouped or
organized? </li>
  <li> Are there relationships between different data items? Does one
data item "contain" another one? </li>
</ul>
When the schema is well defined, then Chandler will be able to easily
aggregate one application's data with another. Chandler is very good at
managing lists and hierarchies of different kinds of data.
<p> For <a class="twikiLink"
 href="http://wiki.osafoundation.org/bin/view/Projects/ZaoBao">ZaoBao</a>,
there are a few key pieces of data: </p>
<ul>
  <li> An RSS feed itself - the data that you download from a web
server. A feed has a title, a last-updated date, and maybe a copyright.
Each RSS feed contains one or more news items. A feed is sometimes
called a channel. </li>
  <li> A news item - this is a single entry retrieved via RSS. News
items have the content of the news item, as well as a date, author,
URL, and so forth. Not all RSS feeds contain authors or even dates but
they all contain content. </li>
</ul>
<h3>Describing the data with Python </h3>
<p>Python classes are the fundamental data type that help us define our
schema. Data is defined as attributes of a given class. The schema
syntax is similar to that used in the Django project.</p>
<p>We'll store our data definitions in <code>feeds/channel.py</code>. </p>
<p>Lets take a look at the basic definition of an RSS channel,
FeedChannel.</p>
<pre class="code">from osaf import pim<br>from application import schema<br><br>class FeedChannel(pim.ListCollection):<br><br>    link     = schema.One(schema.URL, displayName=u"RSS Feed URL")<br>    category = schema.One(schema.Text)<br>    author   = schema.One(schema.Text)<br>    date     = schema.One(schema.DateTime)

    def Update(self):
        # TODO: refresh the feed list from the url 
        pass</pre>
<p>The <code>link</code>, <code>category</code>, <code>author</code>, and <code>date</code> attributes are all basic
attributes using simple types defined in the schema module. The <code>Update()</code> method is like any other python method. </p>
<p class="callout"><strong>Behind the scenes:</strong> Chandler-specific attributes are defined as class
attributes, but in practice they are actually used as instance
attributes. When you have an instance of FeedChannel</p>
<p>The attributes are all defined using schema.One, which indicates
that there is just one of them per instance of the class. The
displayName parameter </p>
<p>Notice that the FeedChannel class inherits from <code>pim.ListCollection</code>.
This class is a simple chandler-based list of items. We will use this
list to represent the fact that a feed <em>contains</em> one or more
feed items. Note that we have not declared anything about the type of
data that this channel will contain. Chandler collections can contain
any type of item. Each entry in Chandler's sidebar is collection of
some kind. </p>
<p>Now lets look at the definition of a news item:</p>
<pre class="code">class FeedItem(pim.ContentItem):<br><br>    link = schema.One(schema.URL)<br>    author = schema.One(schema.Text)<br>    date = schema.One(schema.DateTime)<br>    content = schema.One(schema.Lob)</pre>
<p>The definition is very similar to FeedChannel. The one important
distinction here is that FeedItem is inheriting from pim.ContentItem.
ContentItem is the base class for all user-visible data in Chandler.</p>
<p>Now that we have defined our types, we need to create a python
module that will include these classes. Create <code>feeds/__init__.py</code> and
add the following line:</p>
<pre class="code">from channels import FeedChannel, FeedItem</pre>
<p>When chandler refreshes the Repository, it will look at all of the
python modules in the parcels/ directory, and include any data
definitions.</p>
<h3>Viewing data definitions </h3>
<p>To see if this works, start chandler with a fresh repository, and
run the web server:</p>
<p>&gt; ./chandler --create -W</p>
<p>Now load your favorite web browser and go to
http://localhost:1888/repo/. On the page that is displayed, you should
see something like this:</p>
<blockquote class="code">
  <ul>
    <li><strong>parcels</strong></li>
    <ul>
      <li><b>amazon</b>: <span class="fake-link">AmazonCollection</span>,
        <span class="fake-link">AmazonController</span>, <span
 class="fake-link">AmazonDetailBlock</span>, <span class="fake-link">AmazonItem</span>
      </li>
      <li><b>feeds</b>: <span class="fake-link">FeedChannel</span>, <span
 class="fake-link">FeedItem</span></li>
    </ul>
  </ul>
</blockquote>
<p>&nbsp; </p>
<h2>The Chandler UI </h2>
<p>Now that we have defined some of the datatypes that <a
 class="twikiLink"
 href="http://wiki.osafoundation.org/bin/view/Projects/ZaoBao">ZaoBao</a>
will manage, we will look at how they integrate into the existing user
interface. There are many ways to integrate into the Chandler UI, but
the simplest (and potentially richest) way is to work within the
framework of the Sidebar, Summary View, and Detail View. <br>
<img src="ChandlerUI.png" alt="Chandler UI" class="diagram" height="340"
 width="484"> </p>
<p>These are the key parts of the chandler UI: </p>
<ul>
  <li>The <strong>Sidebar</strong> is a list of <a class="twikiLink"
 href="http://wiki.osafoundation.org/bin/view/Documentation/Collection">Collections</a>.
An item collection is just a container for Items. </li>
  <li> The <strong>Summary View</strong> is a table that lists the
items in the <a class="twikiLink"
 href="http://wiki.osafoundation.org/bin/view/Documentation/Collection">Collection</a>
that is currently selected in the Sidebar. </li>
  <li> The <strong>Detail View</strong> displays the Item that is
currently selected in the summary view. </li>
</ul>
<p> <a class="twikiLink"
 href="http://wiki.osafoundation.org/bin/view/Projects/ZaoBao">ZaoBao</a>'s
two level hierarchy lends itself well to Chandler's existing user
interface. Feeds (<code>FeedChannel</code>) contain News Items (<code>FeedItem</code>)
and News Items have details. (including a body, url, author, and so
forth) </p>
<p>In the simplest case, an FeedChannel is a collection similar to the
All, In, or Out collections. These collections are implemented with the
<a class="twikiLink"
 href="http://wiki.osafoundation.org/bin/view/Documentation/Collection">Collection</a>
Kind. </p>
<p> <strong>Note:</strong> An <a class="twikiLink"
 href="http://wiki.osafoundation.org/bin/view/Documentation/Collection">Collection</a>
is just that: a generic collection of Items. <a class="twikiLink"
 href="http://wiki.osafoundation.org/bin/view/Documentation/Collection">Collections</a>
can contain any kind of Item, including mail messages, calendar events,
and RSS news items. A <a class="twikiLink"
 href="http://wiki.osafoundation.org/bin/view/Documentation/Collection">Collection</a>
is not a folder however, as a single Items can actually be a member of
multiple <a class="twikiLink"
 href="http://wiki.osafoundation.org/bin/view/Documentation/Collection">Collections</a>.
</p>
<p> Since the Chandler UI understands these basic constructs, we can
create an <a class="twikiLink"
 href="http://wiki.osafoundation.org/bin/view/Documentation/Collection">Collection</a>
for each FeedChannel and Chandler will do its best to display the
members of that collection. </p>
<h3> Creating a menu item </h3>
First we'll need to create a menu item so that the user can enter a URL
for an RSS feed. From there, we'll create an <a class="twikiLink"
 href="http://wiki.osafoundation.org/bin/view/Documentation/Collection">Collection</a>
containing the items from that feed. This collection will appear in the
user interface as an entry in the Sidebar.
<p> We'll use the Event system to receive notification that our menu
item has been selected, and that in turn will run some Python code that
we write.</p>
<p>In <code>feeds/blocks.py</code>, we'll write a function called <code>installParcel</code>.
This function is called whenever the Repository is building the UI for
the first time.</p>
<pre class="code">from application import schema<br>from osaf.framework.blocks import MenuItem, BlockEvent

def installParcel(parcel, oldVersion=None):<br><br>    mainview = schema.ns("osaf.views.main", parcel.itsView)

    MenuItem.update(parcel, "NewFeedChannel",
                    blockName="NewFeedChannelItem",
                    title=_(u"New Feed Channel"),
                    parentBlock=mainview.CollectionMenu)</pre>
<p>Make sure to add this function to <code>feeds/__init__.py</code>:</p>
<pre class="code">from channels import FeedChannel, FeedItem
from blocks import installParcel</pre>
<p>The <code>installParcel()</code> function will be called whenever chandler starts with a fresh Repository. Be sure to use the <code>--create</code> parameter when starting chandler, to ensure that this parcel is installed. You'll need to use <code>--create</code> every time you change anything in <code>installParcel()</code>. </p>
<p>There are two key concepts being used here:</p>
<div class="text-with-diagram">
<img class="diagram" src="parcel-refs.png" width="480" height="250">
<p>First, the <code>mainview</code> variable refers to a specific area
of the Repository using <code>schema.ns()</code>, called a &quot;parcel&quot;. Parcels are  persistent containers for python
objects in the Repository. In this case <code>mainview.CollectionMenu</code> refers to
the object in the "osaf.views.main" parcel, named "CollectionMenu". You
can use the web-based Repository Viewer to view the items in this particular parcel here: <a href="http://localhost:1888/repo/parcels/osaf/views/main">http://localhost:1888/repo/parcels/osaf/views/main</a>.
You can also navigate to this directory by clicking on the "//parcels"
link in the top of the Repository Viewer at <a
 href="http://localhost:1888/repo/">http://localhost:1888/repo/</a>.</p>
<p class="callout"><strong>Note:</strong> Don't worry about second
parameter (<code>parcel.itsView</code>) to schema.ns just yet. The view is more or less a handle used to access the Repository.</p>
</div>
<p>Second, we're not necessarily <em>creating</em> a MenuItem.
Instead, we're <em>updating</em> one named "NewFeedChannel" that may
already be in the Repository. If it doesn't already exist, then it is
created. The name "NewFeedChannel" uniquely identifies it  within the <code>parcel</code> object that is passed to installParcel. The parcel's name is more or
less the same as the current module's name. In this case, the parcel's
name is "feeds" because it exists in the parcels/feeds directory. The named parameters to <code>update()</code> will be mapped directly to
attributes on the MenuItem.</p>
<p>There is a connection between the use of the <code>update()</code>
method, and <code>schema.ns()</code>. The first parameter passed to
<code>schema.ns()</code> above is the name of a parcel. Any
attributes of theThe <code>mainview</code> variable is actually
referencing the parcel named "osaf.views.main" above. Another module
could refer to the "NewFeedChannel" <code>MenuItem</code> like this:</p>
<pre>feeds = schema.ns("feeds", view)<br>feedMenuItem = feeds.NewFeedChannel</pre>
<h3>Introducing Bidirectional References </h3>
<p class="ednote">Is this too early to introduce bidirectional refs? Its nice because its easy to understand, and we don't have to go into great detail. </p>
<div class="text-with-diagram">
<img class="diagram" src="parcel-item-refs.png" width="480" height="250">
<p>But how is this menu item connected to the target menu?</p>
<p>Each parameter to <code>update()</code> sets an attribute in that object. The <code>parentBlock</code> attribute is used to attach  NewFeedsChannel  to the CollectionMenu. This is done with Bidirectional References. The schema for MenuItem and Menu are defined such that if a Menu is a parent of a MenuItem, then the MenuItem is automatically a child of the Menu. </p>
<p>When  CollectionMenu is assigned to NewFeedsChannel's <code>parentBlock</code>, then NewFeedsChannel  is automatically added to the CollectionMenu's <code>childrenBlocks</code>. </p>
<p>The Repository will maintain the integrity of this relationship. We'll see more uses of bidirectional references later in the tutorial. </p>
<p class="callout"><strong>Note:</strong> The parentBlock/childrenBlocks relationship is true for all elements in the UI. </p>
</div>
<h3>Adding Behavior</h3>
<p>Now that we have a menu item created, we want to make it call some existing code. We'll need to create two objects:</p>
<ol>
  <li>A BlockEvent: Each UI element (such as buttons, menu items, etc) can activate an BlockEvent when they are used. An event is merely a container for certain contextual information about the UI and its state. </li>
  <li>A Controller: A controller is a class which is activated when certain BlockEvents are activated. Events are <em>dispatched</em> to different Blocks depending on data stored in the BlockEvent, and the context of the application when the BlockEvent is activated. </li>
</ol>
<p>For ZaoBao, we will dispatch our menu's BlockEvent directly to the controller. </p>
<p>First, we will define the event as a persistent object in our parcel:</p>
<pre class="code">def installParcel(parcel, oldVersion=None):

   .
   .
   newChannelEvent = \
       BlockEvent.update(parcel, "NewFeedChannelEvent",
                         blockName="NewFeedChannel",
                         commitAfterDispatch=True)</pre>
						 
<p>The commitAfterDispatch attribute on BlockEvent guarantees that the Repository data will be saved after the event has been dispatched. The result of the call to update() is actually a reference to the object itself.</p>
<p>We're storing the result of BlockEvent.update() in <code>newChannelEvent</code>. This variable will now reference the actual object, whether it was created or updated. We can use this variable later when we want to refer to the actual event object. </p>
<p>Note that we haven't actually defined controller yet. We'll do that next. For now we'll just use a <code>print</code> statement to make sure everything has been hooked up correctly. </p>
<pre class="code">class FeedController(Block):
    def onNewFeedChannelEvent(self, event):
        import wx
        from application.dialogs import Util

        url = Util.promptUser(wx.GetApp().mainFrame,
                              _(u&quot;New Channel&quot;), _(u&quot;Enter a URL for the RSS Channel&quot;),
                              &quot;http://&quot;)

        print &quot;We want to load %s&quot; % url

def installParcel(parcel, oldVersion=None):
    .
    .
    controller = FeedController.update(parcel, &quot;FeedController&quot;)</pre>
<p>One of the first things you may noticed about FeedController is the name of the first method, <code>on<strong><em>NewFeedChannel</em></strong>Event</code>. The &quot;NewFeedChannel&quot; part of the method name corresponds to the blockName of the event that is being called. When a BlockEvent is dispatched, a method called <code>on + <em>blockName</em> + Event</code> is looked up in the target object. If it exists, then it is called. This BlockEvent is also passed into onNewFeedChannel as the parameter <code>event</code>. </p>
<p>Chandler uses the <a href="http://www.wxwidgets.org/">wxWidgets</a> library for its user interface. The <code>Util</code> library provides a set of routines for prompt and confirmation dialogs. The code in onNewFeedChannelEvent() will simply prompt the user for a URL and then print it to the console. </p>
<h3>Putting it all together </h3>
<p>Now that we have created a MenuItem, a BlockEvent, and a Controller, we need to connect them together. The chain references created with these objects looks something like this:</p>
<p>MenuItem -&gt; BlockEvent -&gt; Controller</p>
<p>You can hook them up in installParcel(). The code belows defines them in the reverse order as we defined them above, so that we have the references available to build this chain of objects. </p>
<pre class="code">def installParcel(parcel, oldVersion=None):
    controller = FeedController.update(parcel, &quot;FeedController&quot;)

    newChannelEvent = \
       BlockEvent.update(parcel, "NewFeedChannelEvent",
                         blockName="NewFeedChannel",<strong><em>
                         dispatchEnum="SendToBlockByReference",
                         destinationBlockReference=controller,</em></strong>
                         commitAfterDispatch=True)

    MenuItem.update(parcel, "NewFeedChannel",
                blockName="NewFeedChannelItem",
                title=_(u"New Feed Channel"),<strong><em>
                event=newChannelEvent,</em></strong>
                parentBlock=mainview.CollectionMenu)</pre>
<p>First, the use of <code>dispatchEnum</code> tells the BlockEvent that it will be dispatched to a specific Block instance. The controller block is retrieved in the call to FeedController.update() and passed as the attribute <code>destinationBlockReference</code>.</p>
<p>Next, newChannelEvent is attached to the MenuItem by passing it as the attribute <code>event</code>. </p>
<p>This completes the chain so that when the user clicks &quot;New Feed Channel&quot; in the &quot;Collection&quot; menu, <code>onNewFeedChannelEvent()</code> is called. </p>
<p>There is a reason for the levels of abstraction just to make a menu call some code:</p>
<ul>
  <li>Multiple UI elements can trigger the same event. This allows a menu and a context menu to both trigger the same code without extra work.</li>
  <li>Events may be dispatched to a specific controller (as seen here), dispatched to the currenly focused UI element, or even broadcast to a number of different controllers or UI elements.</li>
</ul>
<p>This flexibilty allows for a very dynamic interface. </p>
<h2>Creating and Displaying Data in the Sidebar </h2>
<p>We will now add new RSS Feeds to Chandler, so that they appear in the Sidebar. We'll also need to display the list of articles in the summary view, and the actual article itself in the Detail View. </p>
<h3>Downloading Feeds</h3>
<p>We'll be using the Python feedparser library available at <a href="http://www.feedparser.org/">http://www.feedparser.org/</a> </p>
<p>The feed download will occur in FeedChannel's <code>Update()</code> method. We'll need to download the feed information, and then create FeedItems for any items not already in the FeedChannel.</p>
<pre class="code">class FeedChannel(ContentItem):
    .
    .
    .
    def Update(self):
        feeddata = feedparser.parse(self.url)

        existingEntryURLs = [entry.url for entry in self]
		
        for entry in feeddata.entries:
		    # skip articles we already have
            if entry.url in existingEntryURLs:
			    continue
			
			# create the new FeedItem, and populate it
            newFeedItem = FeedItem(title=entry.title,
                                   url=entry.link, 
                                   author=entry.author,
                                   content=entry.content[0].value)

            self.add(newFeedItem)
</pre>
<h3>Adding Collections to the Sidebar </h3>
<p>Recall from above that FeedChannel derived from ListCollection. When we create the FeedChannel collection object, we will add it to the Sidebar so that the user can see it. From here we will focus on the code called in the FeedController's <code>onNewFeedCollectionEvent</code> method.</p>
<p>Creating a FeedChannel object is just like creating any other object in Python, except that you can also pass any attribute values along in the constructor and they will be set automatically.</p>
<p>After creating the channel, we just have to add it to the list of collections that the sidebar uses. </p>
<pre class="code">class FeedController(Block):
    def onNewFeedChannelEvent(self, event):
        import wx
        from application.dialogs import Util

        url = Util.promptUser(wx.GetApp().mainFrame,
                              _(u&quot;New Channel&quot;), _(u&quot;Enter a URL for the RSS Channel&quot;),
                              &quot;http://&quot;)

        # create the feed
        newFeed = FeedChannel(url=url)

        # add it to the sidebar
        sidebarCollections = schema.ns(&quot;osaf.app&quot;, self.itsView).sidebarCollections
        sidebarCollections.add(newFeed)

        # download the data
        newFeed.Update()</pre>
<h3>&nbsp;</h3>
<h2>Periodic Feed Updates</h2>
<p>An RSS reader is only useful if it can periodically fetch news stories without the user's intervention.</p>
<h3>Periodic Tasks</h3>
<p>Chandler leverages the Twisted network library for task management. For the purposes of the Feeds parcel, we'll use the PeriodicTask class to regularly call the RSS update code. </p>
<p>First, we'll make a class whose method will be invoked on a regular basis. In channels.py, add the following class:</p>
<pre class="code">class FeedUpdateTaskClass:

    def __init__(self, item):
	    # create a new view so that our changes are isolated
        self.view = item.itsView


    def run(self):
        # bring in changes from other views
        self.view.refresh()

        # update all FeedChannel items
        for channel in FeedChannel.iterItems(self.view):
            channel.Update()

        # now commit our changes to this view
        self.view.commit()

        # run this task again
        return True</pre>
<p>The FeedUpdateClass implements the basic interface in a PeriodicTask: the <code>run()</code> method is called on a regular interval.</p>
<p>This code introduces some more complex use of repository views, and even stores one in self.view. This is the same type of view as seen earlier in the self.schema() code.</p>
<h3>Repository Views </h3>
<p>A repository view is an interface to the objects in the Repository. As mentioned above, it is sort of a handle into the Repository. However a view is also a way to accumulate a set of changes to the Repository without worrying about changes  interfering from other code. </p>
<div class="text-with-diagram">
<img src="repository-views.png" class="diagram">
<p>All changes made to the Repository are made through a  view. Each view maintains its own set of changes that are written back to the central Repository when the <code>commit()</code> method is called. Changes that have been commited from other views are brought into the current view by using the <code>refresh()</code> method.</p>
<p>The Repository is tightly coupled with the python language. All repository object instances have an implicit <code>itsView</code> attribute that refers to the view where changes are made. When an object's attributes are read or written, the changes happen through the object's <code>itsView</code> view. This is in contrast to other common patterns found in other object databases, such as passing a 'view' parameter along as a parameter to any read/write methods. </p>
</div>
<p>Chandler's user interface runs  on one thread, and all repository operations on this &quot;UI Thread&quot; share the same view. </p>
<p>The FeedUpdateTaskClass may be running on a background thread, and it would be unfortunate if a user changed something in the user interface at the same time that same data is being updated in a background thread. FeedUpdateTaskClass's <code>__init__()</code> method saves the view of the item that was passed in. Chandler will ensure that if this task is running on a separate thread, that it also gets its own view. In this case this view is never shared outside of the current class. This allows the feed updating code make a series of updates without worrying about changes that may happen in another view. When all the updates have happened, then the results are committed back to the Repository. </p>
<h3>Finding objects in the Repository</h3>
<p>The FeedUpdateTaskClass needs to find all FeedChannel instances, and call the <code>Update()</code> method on each one. The method <code>iterItems()</code> is a class method on all classes that inherit from Item. It finds all items of the given class in the Repository. The view parameter to <code>iterItems()</code> is necessary because classes themselves don't exist in any specific view. There is no object with an implicit <code>itsView</code> attribute so it must be specified.</p>
<h3>Running Tasks</h3>
<p>The last step in writing a periodic task is to persist the task information in the repository.</p>
<p>The PeriodicTask class is used to persist information about how and when a task should be run. We need to create a PeriodicTask in the repository with information about how often the task should be run. We'll simply create the class in <code>installParcel()</code> as we did with the blocks earlier. </p>
<pre class="code">def installParcel(parcel, oldName=None):
    .
    .
    .
    from osaf.startup import PeriodicTask
    import datetime

    PeriodicTask.update(parcel, &quot;FeedUpdateTask&quot;,
                        invoke=&quot;feeds.FeedUpdateTaskClass&quot;,
                        run_at_startup=True,
                        interval=datetime.timedelta(minutes=30))</pre>
<p>At startup, Chandler will use <code>PeriodicTask.iterItems()</code> to find all PeriodicTask instances, just like FeedUpdateTaskClass itself does to find FeedChannel classes. It will then register each task with Twisted, which will handle the instantiation and running of our task. </p>
<h2>Displaying Item Detail</h2>
<p>So far, this tutorial has explained how to create collections, add them to the sidebar and update them periodically. If you launch chandler, you will be able to subscribe to an RSS feed and it will appear in the sidebar. When you select the feed in the sidebar with the &quot;All&quot; button pressed in the main toolbar, you should see a table widget in the Summary view with a series of blank lines. Each of these lines represents an article from the RSS feed, even though it isn't displaying any specifics about the article. If you click on one of these blank lines, the detail view will display a mostly-blank view of that particular article, but again it will be mostly blank.</p>
<p>We need to tell Chandler a little more about our data in order for it to display its attributes in the UI.</p>
<h3>Displaying Items in the Summary View</h3>
<p>The summary table displays three attributes of an item: who, about, and date. These attributes are usually not true repository attributes; they are not defined as distinct values within a Python class.</p>
<p>Instead repository attribute <em>redirection</em> is used to forward their references to other attributes in the class. To define this redirection, schema.Role() is used.</p>
<pre class="code">class FeedItem(pim.ContentItem):
    .
    .
    .
    about = schema.Role(redirectTo=&quot;title&quot;)
    who = schema.Role(redirectTo=&quot;author&quot;)
</pre>
<p>In the case of FeedItem, we have already defined a <code>date</code> attribute, so we only need to redirect <code>about</code> and <code>who</code>. Whenever the Summary View wants to know what data to display in the 'about' column, it will call <code>getattr(item, 'about')</code>. This will automatically forward to the <code>title</code> attribute, so it as if the Summary View had called <code>getattr(item, 'title')</code>.</p>
<p>Many different classes of ContentItem may be stored in the summary table. The table needs to be able to ask each item for a common attribute. Instead of requiring each class to manually store data in a shared about attribute from a base class, each class can store its data in a class-specific attribute, and then forward about to the class-specific attribute. </p>
<h3>Displaying Item Attributes in the Detail View</h3>
<p>The detail view is a more complex user interface than just a set of columns. Every important attribute should be displayed to the user, and each attribute may have a special way to display itself, or may require special behavior when it is edited.</p>
<p>The detail view is divided into rows. Generally there is one row per attribute, though more complex displays are possible. Typically a row consists of a label, followed by the value of an attribute.</p>
<p>To display a particular item, you need to define some of the actual user interface elements, and indicate where they should be displayed. User interface components are constructed with <em>Blocks</em>. Blocks are persistent Python objects that wrap wxWidgets classes. </p>
<p>The first step is to define the list of UI elements, and the attributes they will display:</p>
<pre class="code">def installParcel(parcel, oldVersion=None):
    .
    .
    . 
    from osaf.framework.blocks import detail
    detailblocks = schema.ns(&quot;osaf.framework.blocks.detail&quot;, parcel.itsView)
    feedItemRootBlocks = [
         # The markup bar
         detailblocks.MarkupBar,
         detail.makeSpacer(parcel, height=6, position=0.01).install(parcel),

         # Author area
         detail.makeArea(parcel, &quot;AuthorArea&quot;,
             position=0.19,
             childrenBlocks = [
                 detail.makeLabel(parcel, _(u&quot;author&quot;), borderTop=2),
                 detail.makeSpacer(parcel, width=8),
                 detail.makeEditor(parcel, 'author',
                                   viewAttribute=u'author',
                                   border=RectType(0,2,2,2),
                                   readOnly=True), 
             ]
         ).install(parcel),

         # URL
    	    detail.makeArea(parcel, &quot;LinkArea&quot;, 
             position=0.3,
             childrenBlocks = [
                 detail.makeLabel(parcel, _(u'link'), borderTop=2),
                 detail.makeSpacer(parcel, width=8),
                 detail.makeEditor(parcel, 'link',
                                   viewAttribute=u'link',
                                   border=RectType(0,2,2,2),
                                   readOnly=True),
             ]
         ).install(parcel),
     ]</pre>
<p>There are 4 elements of the feedItemRootBlocks:
<dl>
  <dt><code>detailblocks.MarkupBar</code> </dt>
  <dd>This is a reference to an actual block instance in the repository. This particular block is the Markup, or Stamping toolbar that allows an item to be 'stamped' as multiple different classes.</dd>
  <dt><code>detail.makeSpacer()</code> </dt>
  <dd>This creates a small space after the markup bar.</dd>
  <dt><code>detail.makeArea(parcel, &quot;AuthorArea&quot;, ...)</code> </dt>
  <dd>This creates a typical combination of label/editor widgets for the author attribute. </dd>
  <dt><code>detail.makeArea(parcel, &quot;LinkArea&quot;, ...)</code> </dt>
  <dd>This creates a typical combination of label/editor widgets for the link attribute. </dd>
</dl>
<p>Chandler gives users the ability to &quot;Stamp&quot; items to make the actual item appear to be multiple kinds of items at once. (such as a Task and a Calendar Event) When the detail view is asked to display an Item, it will go find the relevant blocks for that item's class, and render them on the screen. Because of  Stamping, the rules for displaying data can get complex when you are mixing different classes together. </p>
<p>There is are separate sets of widgets for each class displayed in the Detail View. If an Item is stamped as more than one class, then it needs to display some combination of the widgets from both classes. For instance, if a FeedItem were stamped as a Calendar Event, then the Detail View must display both the <code>author</code> (from FeedItem) and the <code>duration</code> (from CalendarEvent) of the item, even though these two items appear in different classes. </p>
<p>This problem is alleviated by use of the <code>position</code> attribute. You'll notice that each entry after <code>MarkupBar</code> in <code>feedItemRootBlocks</code> has a <code>position</code> attribute between 0 and 1. This position is used to sort the widgets in the display. 0 represents the top of the Detail View, and 1 represents the bottom. This means that if another Detail View widget has a position of 0.25, then it will appear between <code>AuthorArea</code> and <code>LinkArea</code>.</p>
<h3>Attribute Editors</h3>
<p>Most of the items in the childrenBlocks lists should be relatively self explanatory. <code>makeLabel()</code> and <code>makeSpacer()</code> simply make a label and a spacer to the left of the actual detail view. The third item, <code>makeEditor()</code>, creates a widget called an Attribute Editor. An Attribute Editor is a special type of Block that will dynamically create the correct widget to display and/or edit  the given attribute, even if that attribute is a complex type like a Python datetime or a number. </p>
<p>For most basic attributes, an Attribute Editor is the appropriate </p>
<h3>Custom Detail View Attribute Display</h3>
<p>Most attributes can be displayed using  </p>
</body>
</html>
