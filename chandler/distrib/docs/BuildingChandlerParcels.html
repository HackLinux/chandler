<DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"> 
<head> 
 <link rel="stylesheet" href="/twiki/pub/OsafTWiki.css">
 <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />

<title> BuildingChandlerParcels </title>
</head>
<body bgcolor="#ffffff">
<a name="PageTop"></a>

      <center>
<h1><a name="Building_Chandler_Parcels"> </a> Building Chandler Parcels </h1>
<p /><!--
<h3><a name="Alec_Flett_Ted_Leung_Katie_Capps"> </a> Alec Flett, Ted Leung, Katie Capps Parlante </h3>
-->
<p />
<h3><a name="http_www_osafoundation_org_Open"> </a><a name="_http_www_osafoundation_org_Open"> </a> <a href="http://www.osafoundation.org">Open Source Applications Foundation</a> </h3>
 </center>  
<h2><a name="Overview"> </a> Overview </h2>
<p />
Chandler manages data we're all accustomed to using every day -- email, contacts, tasks, notes -- and unifies and organizes it all in a unique way. Chandler works for common data types out of the box, and it's easy to extend Chandler to work with custom data.
<p />
<img src="chandler-0.6-summary.png" alt="chandler_screenshot.png"  width="876" height="596"/>
<p />
In Chandler a user's data is made up of <strong>Items</strong> and collections of Items, which we call <strong>Item Collections</strong>. An Item could be a calendar event, email message, task, note, photo, etc. An Item Collection is a heterogenous group of these Items. The center table in the screenshot above demonstrates a collection of arbitrary Items.  This reflects one of our design goals for Chandler -- instead of trapping data in individual application "silos" (email in an mail reader, calendar events in a calendar application) Chandler provides a flexible, unified domain where all the data can live.  
<p />
Out of the box, Chandler will support types commonly found in a Personal Information Manager: email, contacts, calendar events, tasks, and notes. Chandler's data handling is designed to make it easy for users to plug in their own data types and behaviors -- as simple as adding attributes to an existing Item type or as complex as defining a new Item type, with its own schema, data handling code, and UI code.
<p />
Our example extension for Chandler, Feeds, extends Chandler to deal with RSS or Atom feed data (in the rest of this paper we'll use RSS to mean RSS or Atom data or feeds). Eventually we want to enable end users to extend and customize Chandler with minimal to no programming.
<p />
To get a feel for Chandler's design and see how customization works, we'll walk though the major steps that make up the Feeds example. For a more detailed walkthrough of the same extension, see the tutorial at <a class="twikiLink" href="/bin/view/Documentation/ZaoBaoTutorial">http://wiki.osafoundation.org/bin/view/Documentation/ZaoBaoTutorial</a>.
<p />
<h3><a name="Basics_of_the_Chandler_UI"> </a> Basics of the Chandler UI </h3>
<p />
First, lets cover some of the basic elements of Chandler's user interface:
<p />
<img src="http://wiki.osafoundation.org/pub/Documentation/BuildingChandlerParcels/ChandlerUI.png" alt="ChandlerUI.png"  width="484" height="340"  />
<p />
At first glance, our three pane view looks pretty familiar. The <strong>Sidebar</strong> contains a set of <strong>Item Collections</strong>, and one of them is selected. The <strong>Summary View</strong> displays the <strong>Items</strong> from the <strong>Item Collection</strong>, and one Item is selected. The <strong>Detail View</strong> displays the selected Item. 
<p />
Feeds is going to extend Chandler to add RSS Items to our mix of Items. To integrate RSS data, we need to...
<p />
<ol>
<li> Extend Chandler's schema by defining two new kinds of Items: one for an RSS channel (or feed), and one for the individual RSS news Items.
</li>
<li> Create a background task that will periodically retreive RSS Items for the RSS channels in our repository.
</li>
<li> Connect the RSS channels and Items to the user interface. 
<ul>
<li> Add a menu handler to add collections of RSS Items to the Sidebar.
</li>
<li> Extend schema for RSS Items to display properly in the Summary View.
</li>
<li> Define a UI element for RSS Items to display properly in the *Detail View.
</li>
</ul>
</li>
</ol>
<p />
<h2><a name="1_Adding_RSS_Item_and_RSS_Channe"> </a> 1. Adding RSS Item and RSS Channel: Extending Chandler's Schema </h2>
<p />
Before we start extending Chandler's schema, we'll introduce you briefly to Chandler's <strong>Repository</strong>. Chandler's Repository is a single database that stores all information about all data used in Chandler. An <strong>Item</strong> is the simplest kind of object that can be stored in the Repository. Once Items are created in the Repository, they will persist across all invocations of Chandler until they are explicitly deleted. The Schema API tries to make working with Items look like working with regular Python objects.
<p />
An Item is really just a bunch of <strong>Attribute</strong> values. For example, a calendar event Item would have attributes such as <code>startTime</code>, <code>endTime</code>, etc. Every Item has a <strong>Kind</strong> that determines what Attributes that Item can have.  Calendar event Items would have a Kind of <code>CalendarEvent</code>, which would list the Attribute definitions for <code>startTime</code>, <code>endTime</code>, etc.
<p />
In the examples that follow, you'll see names like <code>schema.Text</code>.  These names are taken from the module for the schema API, which is in the module <code>application.schema</code>, which has been imported as <code>schema</code>.  For Feeds, let's define a <strong>Kind</strong> for an RSS channel:
<p />
<pre>
class FeedChannel(pim.ListCollection):

    schema.kindInfo(displayName=u"Feed Channel")

    link = schema.One(
        schema.URL,
        displayName=_(u"link")
    )

    category = schema.One(
        schema.Text,
        displayName=_(u"Category")
    )

    author = schema.One(
        schema.Text,
        displayName=_(u"Author")
    )

    date = schema.One(
        schema.DateTime,
        displayName=_(u"Date")
    )

    url = schema.One(
        schema.URL,
        displayName=u"URL"
    )

    etag = schema.One(
        schema.Text,
        displayName=u"eTag"
    )

    lastModified = schema.One(
        schema.DateTime,
        displayName=u"Last Modified"
    )

    copyright = schema.One(
        schema.Text,
        displayName=u"Copyright"
    )

    language = schema.One(
        schema.Text,
        displayName=u"Language"
    )

    isUnread = schema.One(
        schema.Boolean,
        displayName=u"Is Unread"
    )

</pre>
<p />
The Schema API uses Python to describe Kinds.   It does this by making
a correspondence between Python classes and Kinds.  Our <code>FeedChannel</code>
Kind is derived from the <code>ListCollection</code> kind, which is defined in the
<code>pim</code> module (which is as short name for <code>osaf.pim</code>.
The <code>schema.kindInfo</code> function is used to set the values of attributes on the
Kind isself.  The attributes of the Kind are defined as attributes of the Python class, 
and use subclasses of <code>schema.Role</code> such as <code>schema.One</code> to define the
type of relationship for each attribute (One to One, One to Many, and
so forth).  The <code>FeedChannel</code> inherits a <code>contents</code> attribute from
<code>ListCollection</code>, which is the container for the various
items in the RSS feed.
<p />
Now let's define a Kind for Items in an RSS feed, representing a single news Item in a Feed channel. 
<p />
<pre>
class FeedItem(pim.ContentItem):

    schema.kindInfo(displayName=u"Feed Item")

    link = schema.One(
        schema.URL,
        displayName=_(u"link")
    )

    category = schema.One(
        schema.Text,
        displayName=_(u"Category")
    )

    author = schema.One(
        schema.Text,
        displayName=_(u"Author")
    )

    date = schema.One(
        schema.DateTime,
        displayName=_(u"Date")
    )

    channel = schema.One(
        FeedChannel,
        displayName=u"Channel"
    )

    content = schema.One(
        schema.Lob,
        displayName=u"Content"
    )

</pre>

<p />
As you can see, <code>FeedItem</code> contains four attributes: <code>channel</code>, <code>author</code>, <code>date</code>, and <code>content</code>. The attribute <code>channel</code> refers back to the original <code>FeedChannel</code>, and <code>content</code> is a <em>Lob</em> - or Large Object. We'll be storing potentially large chunks of HTML in this attribute so we'll use <em>Lob</em> rather than <em>Text</em>.<font color="red">Why? Lob vs Text</font>
<p />
<strong>Behind the scenes: Repository</strong> 
<p />
Everything in the Repository is an Item, including Kinds themselves.  
<p />
You may have noticed that our Feed Item has a <strong>SuperKind</strong> called <code>ListCollection</code>. This reflects an inheritance hierarchy:  <code>ListCollection</code> is another Kind representing an explictly maintained list of Items.  <code>ListCollection</code> is itself derived from a Kind name <code>ContentItem</code> which should be used as the starting SuperKind for all Kinds representing user data.
<p />
<h3><a name="Adding_behavior_with_Python"> </a> Adding behavior with Python </h3>
<p />
This data definition is useful, but we probably want to define some behavior for <code>FeedChannel</code>s and <code>FeedItem</code>s. We can define methods and implement them using Python.  For example, we might want to be able to call a method, <code>Update()</code> on an <code>FeedChannel</code> Item which updates the feed's info from the server.  All we need to do is define that method in the <code>FeedChannel</code> class.
<p />
<pre>
class FeedChannel(pim.ListCollection):
...
    def Update(self, data):
        # fill in the item
        ...
</pre>

<p />
<h2><a name="2_Periodically_getting_new_RSS_I"> </a> 2. Periodically getting new RSS Items: PeriodicTask </h2>
<p />
Most RSS Aggregators will periodically poll the source of the feed in order to download new Items.  We'd like Feeds to do the same thing. Chandler provides an Kind called a <code>PeriodicTask</code> which is used to implement this type of functionality.
<p />
First, we'll use Python to create new items in the repository.
<p />
<pre>
    startup = schema.ns("osaf.startup", parcel)
    
    startup.PeriodicTask.update(parcel, "FeedUpdateTask",
        invoke="feeds.FeedUpdateTaskClass",
        run_at_startup=True,
        interval=datetime.timedelta(minutes=30)
    )
</pre>

<p />
The <code>schema.ns</code> function gives you a namespace which allows to refer
to both the Kinds (classes) and Items (instances) defined in a Parcel (module).  
In this example we are getting the namespace for the <code>osaf.startup</code> Parcel.
<p />
We use the the <code>update</code> method of the
<code>schema.Item</code> class to create a new
<code>PeriodicTask</code> item, and to set the values of its
attributes.  This new <code>PeriodicTask</code> whill be invoked at
startup and every 30 minutes thereafter.  The actual periodic behavior
is described by <code>feeds.FeedUpdateTaskClass</code>.
<p />
The startup parcel automatically finds all Items of Kind
<code>PeriodicTask</code> and runs them according to the specified frequency.
<p />
<pre>
class FeedUpdateTaskClass:

    def __init__(self, item):
        self.view = item.itsView.repository.createView("Feeds")

    def run(self):
        self.view.refresh()

        for channel in FeedChannel.iterItems(self.view):
            try:
                channel.Update()
            except socket.timeout:
                logger.exception('socket timed out')
                pass
            except:
                logger.exception('failed to update %s' % channel.url)
                pass
        try:
            self.view.commit()
        except Exception, e:
            logger.exception('failed to commit')
            pass

        return True     # run it again next time

</pre>

<p />
The Feeds <code>PeriodicTask</code> retreives new RSS data every 30 minutes.
<p />
<strong>Behind the scenes: Threading</strong>
<p />
wxWidgets, like all GUI frameworks, needs to run in a single thread. We're currently using the Twisted Reactor to schedule work that needs to happen outside that thread. The Reactor runs in a separate thread, and is used to schedule the PeriodicTasks found in the Repository.
<p />
<img src="http://wiki.osafoundation.org/pub/Documentation/BuildingChandlerParcels/pyconpaper.png" alt="pyconpaper.png"  width="364" height="221"  />
<p />
A thread in the Repository has its own <strong>Repository View</strong>, which is an independent connection to the Repository. Each PeriodicTask has its own <strong>Repository View</strong>, as does the main wxWidgets UI thread. Different tasks and threads communicate with each other through the repository. After Feeds's PeriodicTask creates new Items in its Repository View, it calls <strong>commit()</strong> on the Repository View, which pushes the Items to the Repository. The UI thread calls <strong>refresh()</strong> on its Repository View during its OnIdle cycle, picking up the new changes. 
<p />
<h2><a name="3_Connecting_the_data_to_the_use"> </a> 3. Connecting the data to the user interface </h2>
<p />
Our next step is to get RSS Items to show up in Chandler's interface. We'll add a menu handler to add collections of RSS Items to the <strong>Sidebar</strong>, modify the schema so the <strong>Summary View</strong> can display RSS Items, and extend the <strong>Detail View</strong> to display RSS Item attributes.
<p />
<h3><a name="Creating_a_Menu_Handler"> </a> Creating a Menu Handler </h3>
<p />
Let's start by adding a new menu item for creating a Collection of RSS Items from an RSS feed.  A menu is an Item of Kind <code>MenuItem</code>, so we'll define just like all the other Items we've seen so far.
<p />
<pre>
    blocks = schema.ns('osaf.framework.blocks', parcel)

</pre>
<pre>
    blocks.MenuItem.update(parcel, "NewFeedChannel",
        blockName = "NewFeedChannelItem",
        title = _(u"New Feed Channel"),
        event = NewFeedChannelEvent,
        eventsForNamedLookup = [NewFeedChannelEvent],
        parentBlock = main.CollectionMenu,
    )

</pre>

<p />
The <code>MenuItem</code> is attached to the <code>CollectionMenu</code>, which is the menu you see when you select the Collection item in the menu bar.   When you select the menu item, it will fire the <code>NewFeedsChannelEvent</code>, which we'll define next.   As with menu items, events are also Items.
<p />
<pre>
    NewFeedChannelEvent = blocks.BlockEvent.update(
        parcel, "NewFeedChannelEvent",
        blockName="NewFeedChannel",
        dispatchEnum="SendToBlockByReference",
        destinationBlockReference=feed_controller,
        commitAfterDispatch=True,
    )

</pre>

<p />
When a <code>NewFeedsChannelEvent</code> is fired, it will be sent to the <code>onNewFeedsChannelEvent</code> method of Feeds' controller, <code>FeedController</code>. 
<p />
<pre>
class FeedController(Block.Block):
    def onNewFeedChannelEvent(self, event):
        import wx
        url = application.dialogs.Util.promptUser(wx.GetApp().mainFrame,
            _(u"New Channel"), _(u"Enter a URL for the RSS Channel"), "http://")
        if url and url != "":
            try:
                # create the feed channel
                channel = channels.NewChannelFromURL(view=self.itsView, url=url,
                                                     update=True)

                schema.ns("osaf.app", self).sidebarCollection.add (channel)
                return [channel]
            except:
                application.dialogs.Util.ok(wx.GetApp().mainFrame,
                    _(u"New Channel Error"),
                    _(u"Could not create channel for %(url)s\nCheck the URL and try again.") % {'url': url})
                raise


</pre>

<p />
The <code>onNewFeedsChannelEvent</code> handler takes care of putting up a dialog and prompting the user for the URL of the RSS feed.
Then the controller calls <code>NewChannelFromURL</code> to create an RSSChannel object and populate it with data from the RSS feed.using the feedparser.  Next, the list of <code>RSSItems</code> is added to the Sidebar. <code>channel</code> is a ListCollection that contains the <code>RSSItem</code> objects. This collection is managed by the <code>RSSChannel</code> : Items will be added each time the RSS feed is updated. We add this Collection to the Sidebar by posting an event to the view. This ItemCollection will appear as a single entry in the Sidebar.
<p />
<pre>
def NewChannelFromURL(view, url, update = True):
    data = feedparser.parse(url)

    if data['channel'] == {} or data.get('status', None) == 404:
        return None

    channel = FeedChannel(view=view)
    channel.url = channel.getAttributeAspect('url', 'type').makeValue(url)

    if update:
        try:
            channel.Update(data)
        except:
            channel.delete()
            raise

    return channel

</pre>

<p />
<strong>Behind the scenes: CPIA (Chandler Presentation Interaction Architecture)</strong> 
<p />
The high-level UI elements in Chandler (like the Sidebar, the Detail View, the Summary View, Menus, the Toolbar and Status Bar) are also Items, and they are stored in the repository just like any other Kind of Item.  UI element kinds are derived from the 'Block' Kind, and so we call them "Blocks". Blocks represent the "View/Controller" in our variant of a Model-View-Controller architecture. Collections of <strong>ContentModel</strong> Items (RSS Items, calendar events, mail messages, etc.) make up the "Model". Each Block has a "contents" Attribute, connecting it to its Model.  In the case of the Summary View, its "contents" is the ItemCollection selected in the Side Bar. In the case of the Detail View, its "contents" is the currently selected Item in the Summary View. The actual GUI implementation of the Block is handled by a wxWidgets peer.
<p />
<h3><a name="Displaying_Items_in_Summary_View"> </a> Displaying Items in Summary View </h3>
<p />
When the user clicks on a collection in the Sidebar, the Summary View automatically displays the Items in that collection. In RSSChannel collections the Items are RSSItems. 
<p />
By default, the Summary View displays the <code>who</code>, <code>about</code>, and <code>date</code> attributes in its columns.
<p />
As we have defined it, the RSSItem does not define all of these attributes. This is normal as these are very generic attributes. Typically a Kind will define a series of "redirect" attributes with these names. These "redirect" attributes are like virtual attributes that actually refer to values in other attributes. Typically, <code>about</code> refers to the title of an Item, <code>who</code> refers to an author or creator of an Item, and <code>date</code> refers to some relevant date stored in the Item such as the due date or the start date.
<p />
In the case of RSSItem, <code>about</code> should redirect to the title of the article, and <code>who</code> should redirect to the author.
<p />
We will add these "redirect" attributes to our original definition for the Kind:
<pre>
    about = schema.Role(redirectTo="displayName")
    who = schema.Role(redirectTo="author")
    body = schema.Role(redirectTo="content")

</pre>

<p />
This is all the code that is required to display Items in the Summary view. Chandler will take care of all the rest.
<p />
<strong>Behind the scenes: ItemCollections</strong>
<p />
Under the hood, ItemCollections are implemented as data structures which send notifications.  Some of these data structures are virtual and represent operations on sets of items.  These virtual collections can be composed to create queries over the contents of the repository.  All collections support the ability to notify interested parties of changes to their contents,
<p />
<h3><a name="Displaying_an_Item_s_Detail_View"> </a> Displaying an Item's Detail View </h3>
<p />
When the user clicks on an Item in the Summary View, the Detail View will display details about that particular Item. Like the Summary View, the Detail View knows about certain attributes and can display them automatically. Unlike the Summary View, each Kind can display a different set of attributes in the Detail View, in its own unique way.
<p />
A Kind can define the user interface for the Detail View by providing a "Trunk Subtree" which defines a list of user interface elements to display:
<p />
<pre>
    detail.DetailTrunkSubtree.update(parcel, "ChannelSubtree",

        # This ensures that this detail view gets attached to feed items
        key = feeds.FeedItem.getKind(parcel.itsView),

        # UI Elements for detail view
        rootBlocks = [
            detail.MarkupBar,

            FeedItemDetail.update(parcel, "ItemBodyArea",
                blockName = "articletext",
                size = SizeType(100,50),
                minimumSize = SizeType(100,50),
            ),

            # URL
            pair("LinkArea", viewAttribute=u"link", position=0.3,
                childrenBlocks = [
                    label("LinkLabel", title=u"link"),
                    LinkDetail.update(parcel, "LinkAttribute",
                        characterStyle = blocks.CharacterStyle.update(
                            parcel, "LinkStyle",
                            fontFamily = "DefaultUIFont",
                            fontSize = 10, fontStyle = "underline",
                        ),
<!--
                        # huh, I only seem to be able to apply this to whole
                        # ContentItemDetail items:
                        #
                        # colorStyle = blocks.ColorStyle.update(
                        #     parcel, "LinkColor",
                        #     foregroundColor = ColorType(0,0,255,255),
                        # ),
-->
                        stretchFactor = 0.0,
                        textAlignmentEnum = "Left",
                        title = u"linkattribute",
                    ),
                ],
            ),

            # Author area
            pair("AuthorArea", viewAttribute=u"author", position=0.19,
                childrenBlocks = [
                    label("AuthorLabel", title=u"author"),
                    field("AuthorAttribute", title=u"author"),
                ]
            ),

            # Date area
            pair("DateArea", viewAttribute=u"date", position=0.4,
                childrenBlocks = [
                    label("DateLabel", title=u"date"),
                    DateDetail.update(parcel, "DateAttribute",
                        title=u"date",
                        characterStyle=blocks.LabelStyle,
                        stretchFactor=0.0,
                        textAlignmentEnum="Left",
                    ),
                ],
            ),

            # Category
            pair("CategoryArea", viewAttribute=u"category",
                position=0.2,
                childrenBlocks = [
                    label("CategoryLabel", title=u"category"),
                    field("CategoryAttribute",
                        title=u"category", stretchFactor=1.0
                    ),
                ]
            ),
        ],
    )

</pre>

<p />
Each <code>rootBlocks</code> attribute refers to a widget or fragment of user interface which will be displayed in the Detail View. Chandler will ensure that these user interface fragments will display and edit the correct data in a consistent way.
<p />
<h2><a name="Loading_the_Items_into_Chandler"> </a><a name="Loading_the_Items_into_Chandler_"> </a> Loading the Items into Chandler: Parcels </h2>
<p />
We have now defined schema <strong>Kind</strong> Items, defined a <strong>PeriodicTask</strong> Item for a background task, defined a <strong>Menu</strong> Block and associated <strong>Event</strong> to add new behavior, and defined a <strong>DetailTrunkSubtree</strong> Item to customize the UI. We've also associated Python code with several of these Items. We add these enhancements to Chandler by defining a Parcel. A Parcel defines Items to be loaded into the repository. Once those Items are in the repository, they are discovered by queries against the repository, or they are discovered because they are linked to other well known Items in the repository.
<p />
Chandler uses parcels to define much of the UI framework, and all of the PIM functionality.
<p />
<em>Parcel</em>s are defined in Python modules which contain Kind (Python
class) Item (Python instance) definitions. Chandler scans for modules at startup, and loads each Parcel directly into the repository. While Chandler is running it finds the various data definitions in the repository and activates them when appropriate.   This happens in a module level hook function called <code>installParcel</code>.  The Python code that we've presented for creating Item instances would appear in the body of the <code>installParcel</code> method for that Parcel.
<p />
This is one of the primary patterns that drives Chandler: the repository controls all data in Chandler, and Chandler uses it to discover new application schemas and data. Behavior is determined by code that is attached to this data. 
<p />
<strong>Behind the scenes:</strong> The Python code for Kinds and Items is merely a bootstrapping mechanism to get data loaded into the Repository. The Repository is the primary data store that Chandler uses to keep all user data, schemas, and more. If data that is declared in your Parcel is changed within the Repository, those changes will <em>not</em> be serialized back the Python code in your Parcel..
<p />
<h2><a name="Where_Chandler_is_today"> </a> Where Chandler is today </h2>
<p />
In this paper, you have seen how to:
<p />
<ul>
<li> Define new data types
</li>
<li> Populate the repository with new data
</li>
<li> Display that data in the Sidebar, Summary View, and Detail View
</li>
</ul>
<p />
The next step is to spend some time developing your own data types and application behavior. The steps described here will get you some basic functionality out of your data but Chandler's true potential comes to light when you begin to explore some of its more advanced capabilities. When Items have been properly defined, many of these capabilities "just work" for your new Kind. 
<p />
<h3><a name="Sharing"> </a> Sharing </h3>
<p />
Chandler has a built-in infrastructure for sharing individual Items or entire ItemCollections through <a href="http://wiki.osafoundation.org/bin/view/Jungle/WebDAV">WebDAV</a>. The most immediate and obvious use for this is the capability to share Calendar data. Users can share their data with others and allow them make changes, allowing collaboration using open standards.  By creating your parcel's data as Chandler Items, your data will also be able to take advantage of Chandler's sharing capabilities.
<p />
<h3><a name="Stamping_and_dynamic_types"> </a> Stamping and dynamic types </h3>
Chandler leverages Python's unique typing to allow Items to take on attributes and behavior of multiple Items at runtime. For example, you could turn an RSS news Item as created above into a mail message to send the news with your collegues. Or you can put a mail message on your calendar by just "stamping" it as an event.  As with Sharing, your parcel's Kinds and Items can also be stamped and (will) be usable as stamps.
<p />
<!--
<h3><a name="Future_Directions"> </a> Future Directions </h3>
The Chandler team has been focused on building the infrastructure that support the capabilities demonstrated in this paper.  We are now working hard at building out the end user functionality for Personal Information Management.   As part of that effort we will be doing some work to polish the user interface to provide a richer experience for the user.  This screenshot gives you a taste for the level of visual polish that we want to acheive.
<p />
<img src="http://wiki.osafoundation.org/pub/Documentation/BuildingChandlerParcels/mac_calendar_vertical.png" alt="mac_calendar_vertical.png"  width="1024" height="532"  />
-->
<h2>What to do next</h2>
There is a more detailed <a href="">tutorial</a> on the workings of the Feeds parcel that will explain more of the details of writing a parcel.
<p />
You can visit the Chandler home page for ideas on how to <a href="http://chandler.osafounation.org/getinvolved.php">get involved</a> with the Chandler project.
<p />
Please send comments or corrections on this document to the Chandler <a href="http://lists.osafoundation.org/mailman/listinfo/dev">development</a> mailing list.  If you need more help, the mailing list is the best place to go.

</body>
</html>
